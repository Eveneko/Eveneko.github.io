[{"content":" 时间: 2023-09-21 14:00-15:00 部门: PCG，QQ，短视频推荐 自我介绍 最近自我介绍的时间有意缩短了，留出时间给面试官问他想问的。\n问答 rpc服务，top发现cpu占用率上不去，只有一个线程100%，其他线程闲置，排查一下原因 如何提升rpc性能 连接复用，如何对应请求和回复 epoll+线程池，io比较重，如何优化 malloc需要指定大小，free却不用，如何实现 c++ 关键字 explicit c++ 右值 c++ 多态 重载 虚函数 tcp 粘包 rpc 连接超时，服务端如何如何实现检测 10w长度的int数组，数组元素大小都位于0-1w之间，对数组进行排序，可以怎么办 代码 设计实现双端队列, 实现 Deque 类 ","permalink":"https://eveneko.com/posts/interview/2023-tx-5/","summary":"时间: 2023-09-21 14:00-15:00 部门: PCG，QQ，短视频推荐 自我介绍 最近自我介绍的时间有意缩短了，留出时间给面试官问他想问的。 问答 rpc服务，top发现cpu占用率上不去，只有一个线程100%，其他线程闲置，排查一下原因 如何提升rpc性能 连接复用，如何对应请求和回复 epoll+线程池，io比较重，如","title":"[过] 腾讯 后台开发 一面"},{"content":" 时间: 2023-09-20 19:00-20:00 部门: 广告, 大模型推理平台 自我介绍\n问答\nc++ vector set unordered_set 插入10w次，速度 实现hashmap 并发 hashmap 实现lru缓存 并发 无锁 实现队列 两个数组，整数，有序，求交集 一个很长，一个很短 两个都很长，但是交集很小 ","permalink":"https://eveneko.com/posts/interview/2023-ks-2/","summary":"时间: 2023-09-20 19:00-20:00 部门: 广告, 大模型推理平台 自我介绍 问答 c++ vector set unordered_set 插入10w次，速度 实现hashmap 并发 hashmap 实现lru缓存 并发 无锁 实现队列 两个数组，整数，有序，求交集 一个很长，一个很短 两个都很长，但是交集很小","title":"快手 C++开发工程师 二面"},{"content":" 时间: 2023-09-20 16:30 5分钟面试 自我介绍 2分钟 问答 简历上的链接是什么 个人主页 看你报了很多大厂 私企开的早，你们上周来学校宣讲才报 想做什么方向 技术 接受转岗吗 想发挥自己的优势 这是一面，过了会有笔试，笔试过了会有二面。\n:)\n","permalink":"https://eveneko.com/posts/interview/2023-yd-1/","summary":"时间: 2023-09-20 16:30 5分钟面试 自我介绍 2分钟 问答 简历上的链接是什么 个人主页 看你报了很多大厂 私企开的早，你们上周来学校宣讲才报 想做什么方向 技术 接受转岗吗 想发挥自己的优势 这是一面，过了会有笔试，笔试过了会有二面。 :)","title":"上海移动 一面"},{"content":"C++ C++11语法特性\n初始化列表\n四种cast\n委托构造和继承构造\n1 using Base::Base; 关键字 auto decltype final/override default/delete/explicit const/constexpr using/deftype thread_local Lambda 表达式\nlambda std::function std::bind 智能指针\nNetwork OS Redis 手撕代码 ","permalink":"https://eveneko.com/posts/interview/mj/","summary":"C++ C++11语法特性 初始化列表 四种cast 委托构造和继承构造 1 using Base::Base; 关键字 auto decltype final/override default/delete/explicit const/constexpr using/deftype thread_local Lambda 表达式 lambda std::function std::bind 智能指针 Network OS Redis 手撕代码","title":"通用面经"},{"content":" 时间: 2023-08-17 14:30-16:00 部门: 腾讯，PCG，QQ 场外因素: 面试官有事去了，换了一个同事来面试的 面试后一个小时内结束流程\u0026hellip;\n自我介绍 好久没面试了，项目经历更新了，没有准备小作文，临床发挥一般，有一点小乱，不过逻辑是自洽的。\n反馈：背景不错，经历不错，看起来挺自信的。\n八股 计算机网络 ipv4和ipv6的区别 ipv6删除CRC校验和的原因 socket的连接步骤，分服务端和客户端 服务端 udp write的时候，操作系统做了什么，用户态到内核态，流程 弱网场景，tcp面临的问题，解决方法 慢启动过程 弱网环境下，调整数据包的大小的影响 操作系统 进程线程和协程的区别 fork后，线程继承了进程的什么 继承堆栈吗 你知道哪些hash算法 hash碰撞的解决办法 hash高并发读写优化方案 redis 11亿qq号以及个人信息存进redis，怎么存，设计结构，可能存在的问题 redis有哪些数据结构 Zset的底层实现 跳表的实现 跳表和红黑树的区别 反馈：基本都了解，但是感觉准备不够充分\n算法题 合并有交集的区间，例如[1, 10], [2, 11], [50, 100], 合并之后的结果是[1, 11], [50, 100] 做法: 对每个区间排序，排序依据第一个元素\n实现非递归的快速排序 做法: 用栈模拟\n反问 技术栈 业务方向 ","permalink":"https://eveneko.com/posts/interview/2023-tx-1/","summary":"时间: 2023-08-17 14:30-16:00 部门: 腾讯，PCG，QQ 场外因素: 面试官有事去了，换了一个同事来面试的 面试后一个小时内结束流程\u0026hellip; 自我介绍 好久没面试了，项目经历更新了，没有准备小作文，临床发挥一般，有一点小乱，不过逻辑是自洽的。 反馈：背景不错，经历不错，看起来挺自信的。 八股 计算机网络 ipv","title":"[凉] 腾讯 QQ C++后台开发 一面"},{"content":"Q\u0026amp;A 商品来源 烘焙店\n临期食品时间 面包/点心: \u0026lt; 1 day\n饮品: 未知\n目标人群 中低收入群体，包括学生\n服务形式 提供临期食品信息，线上预定\n店面宣传\n盈利方式 前期：\n流量，广告 中后期：\n商品供应方：佣金/手续费 成本 服务搭建成本\n商品供应方：前期无成本\n服务范围 前期：日照\n中后期：青岛\n竞品 北京，上海，济南 ✅\n日照 ❎\n小程序开发时间 根据功能工作量确定\n基础：\n用户侧 注册，登陆，个人信息 查看信息 预定 商品 到店时间 消息 系统 供应侧 注册，登陆，个人信息 上架商品 照片 商品名 原材料 保质期 数量 原价 临期价 其他(option) 消息 预定 系统 进阶\n用户侧 信誉系统 供应侧 评价系统 预计开发时间 前端：2 weeks 后端：2 weeks ","permalink":"https://eveneko.com/posts/tgtg/","summary":"Q\u0026amp;A 商品来源 烘焙店 临期食品时间 面包/点心: \u0026lt; 1 day 饮品: 未知 目标人群 中低收入群体，包括学生 服务形式 提供临期食品信息，线上预定 店面宣传 盈利方式 前期： 流量，广告 中后期： 商品供应方：佣金/手续费 成本 服务搭建成本 商品供应方：前期无成本 服务范围 前期：日照 中后期：青岛 竞品 北京，上海，济南 ✅ 日照 ❎","title":"中国TooGoodToGo开发探索"},{"content":"记录 公司 更新日期 状态 工作地点 岗位 蔚来 2023-07-20 实习不转正 北京/上海 自动驾驶系统优化 百度 2023-08-28 二面 北京 C++/PHP/GO研发工程师(J59431) 字节 2023-08-10 流程终止 北京 提前批-后端开发工程师-基础架构 字节 2023-08-24 笔试 北京 后端开发工程师-基础架构 腾讯 2023-10-12 一面 深圳 应聘进度 美团 2023-08-25 已结束 北京 自动驾驶系统工程师 美团 2023-08-31 已结束 北京 无人配送/机器人软件开发工程师 美团 2023-09-06 已结束 北京/上海 后端开发工程师 京东 2023-08-23 流转 北京/上海/深圳 后端开发工程师 小红书 2023-08-23 用人部门筛选 北京/上海 C++开发工程师-引擎架构 米哈游 2023-08-20 流程结束 上海 游戏服务器开发 滴滴 2023-09-22 三面 北京 正式批-软件开发工程师-（C/C++）-TIG 快手 2023-08-24 一面 北京 性能分析工程师 快手 2023-08-28 用人部门筛选 北京 Linux操作系统研发工程师 快手 2023-09-19 二面 北京/杭州 C++开发工程师 大疆 2023-09-08 已结束 深圳 C++开发工程师 招商银行 2023-09-20 二面 北京 进展 深信服 2023-09-24 口头oc 深圳 C/C++软件开发工程师 阿里-控股 2023-08-31 已投递 北京/杭州 基础平台研发 阿里-阿里云 2023-09-03 已结束 北京 基础平台研发工程师 阿里-淘天 2023-08-31 已投递 杭州 研发工程师C/C++ 阿里-饿了么 2023-09-04 已结束 上海/杭州 研发工程师Golang 阿里-国际 2023-09-15 已结束 北京 研发工程师C/C++ 阿里-灵犀互娱 2023-09-26 已投递 广州 游戏开发工程师 阿里-高德 2023-10-10 一面 北京 C++开发工程师-导航规划 阿里-菜鸟 2023-09-01 已投递 杭州 研发工程师C++ 蚂蚁 2023-09-23 已投递 全国 研发工程师C/C++ 网易 2023-09-23 笔试 杭州 C++开发工程师 小米 2023-09-26 一面 北京/南京 Linux软件工程师-手机 RedHat Software Quality Engineer - Linux Kernel BOSCH 2023-09-01 初筛 软件工程师 - Linux 地平线 2023-09-04 岗位下架 北京/南京 C++研发工程师(runtime方向) 比亚迪 2023-09-03 已投递 北京/深圳 2024届秋季招聘 文远知行 2023-10-09 二面 广州 投递记录 科大讯飞 2023-09-07 简历筛选 苏州/合肥/武汉 C++开发工程师 荣耀 2023-10-11 笔试 北京 通用软件开发工程师 三星 2023-09-21 已申请 SRCX-系统安全工程师 momenta 2023-09-26 已申请 系统研发工程师-C++ 联想 2023-09-26 已申请 Linux开发工程师 特斯拉 2023-09-26 已申请 软件开发工程师 NVIDIA 2023-09-26 已申请 System Software Engineer 国家电网-南瑞 2023-10-09 面试 申请 苏小研 2023-09-28 已申请 小马智行 2023-10-09 一面 研发工程师 理想 2023-09-29 已申请 我的投递 云鲸智能 2023-10-07 已申请 嵌入式开发工程师-Liunx系统服务 度小满 2023-10-07 已申请 后端研发工程师 tplink 2023-10-09 已申请 软件工程师（上海）-操作系统 战略支援部队 2023-9-14 已申请 移动-上海 2023-9-19 一面 国安-上海 2023-9-29 线下双选会 中国电信-江苏 2023-10-08 已申请 面经 [2023-10-16] 腾讯 一面 20:00 [2023-10-16] 高德 一面 14:00 [2023-10-13] 文远知行 研发工程师 二面 10:00 [2023-10-12] 小马智行 一面 14:00 [凉][2023-10-11] 腾讯 后台开发 三面 19:00 [过][2023-10-11] 招银网络科技 二面+hr面 15:00 [2023-10-09] 南瑞 10:30 [过][2023-09-27] 小米 Linux软件工程师 一面 13:00 [过][2023-09-27] 文远知行 研发工程师 一面 10:00 [过][2023-09-26] 腾讯 后台开发 二面 [过][2023-09-25] 招银网络科技 后端开发 一面 16:50 [过][2023-09-25] 深信服 软件开发工程师 hr面 11:00 [过][2023-09-25] 深信服 软件开发工程师 二面 9:40 [过][2023-09-24] 深信服 软件开发工程师 一面 16:00 [泡][2023-09-22] 滴滴 软件开发工程师 三面 20:00 [过][2023-09-22] 滴滴 软件开发工程师 二面 19:00 [过][2023-09-22] 滴滴 软件开发工程师 一面 16:00 [过][2023-09-21] 腾讯 后台开发 一面 [2023-09-20] 快手 C++开发工程师 二面 [2023-09-20] 上海移动 一面 [过][2023-09-14] 快手 C++开发工程师 一面 [凉][2023-09-05] 腾讯 机器学习平台 后台开发 三面 [凉][2023-08-30] 百度 云原生部 二面 [过][2023-08-25] 百度 云原生部 一面 [凉][2023-08-24] 快手 性能分析工程师 一面 [过][2023-08-24] 腾讯 机器学习平台 后台开发 二面 [凉][2023-08-22] 大疆 C++开发工程师 一面 [过][2023-08-22] 腾讯 机器学习平台 后台开发 一面 [凉][2023-08-21] 京东 京东零售-平台运营与营销中心 后台开发 一面/二面 [凉][2023-08-17] 腾讯 QQ 后台开发 一面 笔试 [2023-10-14] 江苏电信 9:00～12:00 [2023-10-12] 荣耀 18:00～21:00 ","permalink":"https://eveneko.com/posts/update/2023-find-job/","summary":"记录 公司 更新日期 状态 工作地点 岗位 蔚来 2023-07-20 实习不转正 北京/上海 自动驾驶系统优化 百度 2023-08-28 二面 北京 C++/PHP/GO研发工程师(J59431) 字节 2023-08-10 流程终止 北京 提前批-后端开发工程师-基础架构 字节 2023-08-24 笔试 北京 后端开发工程师-基础架构 腾讯 2023-10-12 一面 深圳 应聘进度 美团 2023-08-25 已结束 北京 自动驾驶系统工程师 美","title":"2023秋招死亡笔记"},{"content":"本地安装 1 2 3 4 5 # 新建hugo站点 hugo new site \u0026lt;your-blob\u0026gt; # 添加主题 git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 新建文章 1 hugo new \u0026lt;post-path\u0026gt; 本地部署 1 hugo server -D Github Action 新建两个repository: Blob-Source: 私有，博客源码 xxx.github.io: 公开，博客页面 添加个人访问令牌作为TOKEN存储库中调用的Secret 在 Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens (classic)，注意分配权限为 repo, workflow 在 Blob-Source 中 Settings -\u0026gt; Secrets and variables -\u0026gt; Add deploy key 添加上述TOKEN 设置环境变量并将此操作添加到工作流程中 1 2 3 4 - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.DEPLOY_TOKEN }} 设置部署触发条件 1 2 3 4 5 6 7 8 on: push: branches: - master workflow_dispatch: schedule: # Run on the hour - cron: \u0026#39;0 * * * *\u0026#39; ","permalink":"https://eveneko.com/posts/hugo-tutorial/","summary":"本地安装 1 2 3 4 5 # 新建hugo站点 hugo new site \u0026lt;your-blob\u0026gt; # 添加主题 git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 新建文章 1 hugo new \u0026lt;post-path\u0026gt; 本地部署 1 hugo server -D Github Action 新建两个repository: Blob-Source: 私有，博客源码 xxx.github.io: 公开，博客页面 添加个人访问令牌作为TOKEN存储库中调用的Secret 在 Settings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens (classic)，注意分配权限为 repo, workflow 在 Blob-Source 中","title":"Hugo 指北"},{"content":"P2IM Scalable and Hardware-independent Firmware Testing via Automatic Peripheral Interface Modeling\nabstract 嵌入式固件的动态测试或模糊严重限制了硬件依赖和较差的可伸缩性，部分导致了普遍存在的脆弱的物联网设备。我们提出了一种软件框架，它可以持续地执行给定的固件二进制文件，同时从现成的模糊器引导输入，从而支持独立于硬件的、可扩展的固件测试。我们的框架使用了一种名为P2IM的新技术，对各种外设进行抽象，并根据自动生成的模型动态地处理固件I/O。 P2IM与外围设备设计无关，与固件实现通用，因此适用于广泛的嵌入式设备。我们使用70个样本固件和10个来自真实设备(包括无人机、机器人和PLC)的固件来评估我们的框架。在没有任何人工协助的情况下，它成功地执行了79%的样本固件。我们还对真实的固件进行了有限的模糊测试，发现了7个独特的未知bug。\nLimitation 由于DMA的复杂性和特定于外围设备的特性，不支持DMA 超越模糊化的固件分析:虽然我们的工作最初是受到固件模糊化所面临的公开挑战的启发，但它并不是专为支持模糊化而设计的。其他类型的动态固件分析不需要完全准确的固件输出，可以使用我们的框架来实现硬件独立性和可伸缩性。例如，数据或代码的可达性分析，例如污染分析和某些调试任务，可以从我们的框架中受益。 uEmu Automatic Firmware Emulation through Invalidity-guided Knowledge Inference\nabstract 由于硬件和固件之间的紧密耦合，对微控制器进行固件仿真具有挑战性。这极大地阻碍了动态分析工具在固件分析中的应用。最先进的工作是通过观察未知外设的访问模式来自动建模，然后利用启发式来计算当未知外设寄存器被访问时的适当响应。但是，我们根据经验发现，这种方法和相应的启发式方法通常不足以模拟固件。在这项工作中，我们提出了一种新的方法，称为μEmu来模拟固件与未知的外设。与试图为每个外设构建通用模型的现有工作不同，我们的方法学习如何正确地模拟在各个外设访问点上的固件执行。它将固件镜像作为输入，并通过将未知的外围寄存器表示为符号来象征性地执行它。 在符号执行期间，它推断出响应未知外设访问的规则。这些规则存储在一个知识库中，在动态固件分析期间将引用该知识库。μEmu在外设驱动程序单元测试中，在没有任何人工辅助的情况下，达到93%的通过率。我们还用真实的固件样本评估μEmu，发现了新的bug。\nLimitation 缺少对DMA的支持 模糊测试用例不能通过I2C外设的数据寄存器提供给模拟器。 根据特征来识别数据寄存器存在FN μEmu只在上下文包含一个或多个符号时检测无限循环/长循环。真实世界更复杂，循环的计数器可能是一个具体的数字，同时依赖外面的符号。 AutoMap Automatic Firmware Emulation through Invalidity-guided Knowledge Inference\nabstract 在嵌入式设备开发中，同桌面计算机最大的不同之一在于开发者需要对硬件资源进行直接管理（而中间往往没有OS），所以经常会涉及到peripheral也就是我们常说的“外设”的一些操作。下图展示了常见的一些嵌入式设备的外设通信模型。在实际使用中，每一类外设都会在内存中划定一块区域（地址范围），用来作为它们同MCU通信的中间地带。MCU在执行固件代码时，通过读写特定的地址上的值，就实现了同外设的交互。这些特定地址上的基本单元， 在嵌入式开发里面被叫做寄存器（register，注意这种寄存器和桌面、服务器端的CPU上的寄存器差别）。\n安全分析人员经常会使用模拟器来模拟执行嵌入式固件，其中最让人头疼的部分莫过于和外设交互这部分的模拟——外设的执行逻辑并没有体现在任何指令中，单纯一条I/O指令完全反映不出可能的行为模式。 所以很多嵌入式固件模拟分析的工作都试图用一些技巧性的方式来弥补这方面的不足。实际上，现在已经有非常多的同类工作（见下表）\n本文作者指出，在实际的实现过程中，模拟器常常会不正确地模拟嵌入式设备的一些行为 。本文讨论的主要问题就是其中一种“奇异”的行为：在嵌入式设备外设的寄存器中，有一些特定的寄存器之间存在隐性关联关系，一旦其中的一个寄存器发生了变化，其余的也会跟着关联变化，而且这种变化不需要经过MCU的任何干预。 作者把这种现象命名为hidden memory mapping，可以想象，在模拟执行分析时，如果模拟器不知道hidden memory mapping的存在，那么在对一个特定的寄存器进行操作后，并不会去把其他相关寄存器也更新一遍，这可能会导致模拟结果谬以千里。（P2IM和uemu）\n既然知道了问题所在，为了解决这个痛点，作者在Unicorn模拟器的基础上实现了名为AutoMap的系统。按照下图的示意，AutoMap为模拟器准确处理hidden memory mapping增加了一个中间层，可以基于领域知识（domain knowledge）来处理寄存器的隐式关联变化。\n作者在NRF52832，STM32F103和STM32F426进行实验。\nLimitation 为了提取外设寄存器的隐藏内存映射，AutoMap需要相应的硬件MCU，这限制了AutoMap的可扩展性。 不能处理这些数据外围寄存器 Further Work 为更多MCU构建知识库 P2IM和uemu因为隐藏的内存映射而产生不正确的结果，可以去改进 改进算法，提高效率 当我们在每个外设上获得足够的内存映射知识时，我们可以使用机器学习来建模外设。这种实现可能是可行的，因为内存映射可能会有一些清晰的模式和统计特征。最终目标是在没有硬件的情况下从训练过的模型推断内存映射，使AutoMap更具可扩展性和效率。 可能的研究方向 基于AutoMap，从hidden memory mapping改进 P2IM或者uemu。 AutoMap可以进一步集成到模糊处理组件中，这可能有助于在考虑隐藏内存映射时发现更多的漏洞，从而减少误检。 基于AutoMap，使用机器学习来建模外设。 当我们在每个外设上获得足够的内存映射知识时，我们可以使用机器学习来建模外设。这种实现可能是可行的，因为内存映射可能会有一些清晰的模式和统计特征。最终目标是在没有硬件的情况下从训练过的模型推断内存映射，使AutoMap更具可扩展性和效率。 基于P2IM，做一个不是模糊测试的固件测试。 最初P2IM是受到固件模糊化所面临的公开挑战的启发，但它并不是专为支持模糊化而设计的。其他类型的动态固件分析不需要完全准确的固件输出，可以使用这个框架来实现硬件独立性和可伸缩性。例如，数据或代码的可达性分析，例如污染分析和某些调试任务。 pre 基于hideen memory mapping的固件仿真及检测框架\n研究方向 固件仿真，固件动态测试 研究的对象 Iot固件 车辆固件（可选） 研究的目标 对固件二进制文件，在不依赖硬件的前提下，进行仿真； 对外设进行仿真； 在成功仿真的基础上进行包括但不限于模糊测试的动态测试方法试图检测固件漏洞 拟解决的问题 仿真固件的多样性 外设仿真的准确性 自动化仿真 固件仿真后的动态测试 输出的软件/系统，功能，需求 固件仿真/测试框架 研究的创新点 hidden memory mapping未与已有的框架结合 自动化仿真 针对固件检测，使用除了模糊测试的动态测试方法 ","permalink":"https://eveneko.com/posts/master-thesis/","summary":"P2IM Scalable and Hardware-independent Firmware Testing via Automatic Peripheral Interface Modeling abstract 嵌入式固件的动态测试或模糊严重限制了硬件依赖和较差的可伸缩性，部分导致了普遍存在的脆弱的物联网设备。我们提出了一种软件框架，它可以持续地执行给定的固件二进制文件，同时从现成的模糊器引导输入，从而支持独立于硬件的、可扩展的固件测试。我们的框架使用了一种名为P","title":"研究生论文方向: 基于hideen memory mapping的固件仿真及检测框架"},{"content":"例题 已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 k 求出某区间每一个数的和。\n引入 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。\n线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。\n条件 线段树维护的信息可以认为是满足（幺）半群的性质\n封闭性 $\\forall x \\in S$, $\\forall y \\in S$ 有 $\\forall x \\circ y \\in S$ 结合律 $\\forall x,y,z \\in S$ 有 $(x \\circ y) \\circ z = x \\circ (y \\circ z)$ 存在幺元 $\\exist e \\in S$ 满足 $\\forall x \\in S$ 有 $e \\circ x = x$，$e$为左幺元；$x \\circ e = x$，$e$为右幺元； 线段树的基本结构与建树 过程 线段树将每个长度不为1的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。\n有个大小为5的数组 $a={10,11,12,13,14}$，要将其转化为线段树，有以下做法：设线段树的根节点编号为1，用数组 $d$ 来保存我们的线段树，$d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。\n图中每个节点中用红色字体标明的区间，表示该节点管辖的 $a$ 数组上的位置区间。如 $d_1$ 所管辖的区间就是 $[1,5] (a_1,a_2,\u0026hellip;,a_5)$，即$d_1$所保存的值是$a_1+a_2+\u0026hellip;+a_5$， $d_1=60$表示的是$a_1+a_2+\u0026hellip;+a_5=60$。\n通过观察不难发现，$d_i$的左儿子节点是$d_2i$，$d_i$的右儿子节点是$d_2i+1$。如果$d_i$表示的是区间$[s,t]$（即$a_s+a_{s+1}+\u0026hellip;+a_t$）的话，那么$d_i$的左儿子节点表示的是区间$[s,\\frac{s+t}{2}]$，$d_i$的右儿子节点表示的是区间$[\\frac{s+t}{2}+1,t]$。\n在实现时，我们考虑递归建树。设当前的根节点为 $p$，如果根节点管辖的区间长度已经是 1，则可以直接根据 $a$ 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 void build(int s, int t, int p) { // 对 [s,t] 区间建立线段树,当前根的编号为 p if (s == t) { d[p] = a[s]; return; } int m = s + ((t - s) \u0026gt;\u0026gt; 1); // 移位运算符的优先级小于加减法，所以加上括号 // 如果写成 (s + t) \u0026gt;\u0026gt; 1 可能会超出 int 范围 build(s, m, p * 2), build(m + 1, t, p * 2 + 1); // 递归对左右区间建树 d[p] = d[p * 2] + d[(p * 2) + 1]; } 空间 关于线段树的空间：如果采用堆式存储（ $2p$ 是 $p$ 的左儿子，$2p+1$ 是 $p$ 的右儿子），若有 $n$ 个叶子结点，则 $d$ 数组的范围最大为 $2^{[logn]+1}$。\n分析：容易知道线段树的深度是 $[logn]$ 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^[logn]$ 个，又由于其为一棵完全二叉树，则其总节点个数 $2^{[logn]+1}-1$。当然如果你懒得计算的话可以直接把数组长度设为 4n，因为 $\\frac{2^{[logn]+1}-1}{n}$的最大值在$n=2^x+1$时取到，此时节点数为 $2^{[logn]+1}-1=2^{x+2}-1=4n-5$。\n线段树的区间查询 过程 区间查询，比如求区间 $[l.r]$ 的总和（即 $a_l+a_{l+1}+\u0026hellip;+a_r$）、求区间最大值/最小值等操作。\n仍然以最开始的图为例，如果要查询区间 $[1,5]$ 的和，那直接获取 $d_1$ 的值（60）即可。\n如果要查询的区间为 $[3,5]$，此时就不能直接获取区间的值，但是 $[3,5]$ 可以拆成 $[3,3]$ 和 $[4,5]$，可以通过合并这两个区间的答案来求得这个区间的答案。\n一般地，如果要查询的区间是 $[l,r]$，则可以将其拆成最多为 $O(logn)$ 个 极大 的区间，合并这些区间即可求出 $[l,r]$ 的答案。\n实现 1 2 3 4 5 6 7 8 9 10 11 int getsum(int l, int r, int s, int t, int p) { // [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号 if (l \u0026lt;= s \u0026amp;\u0026amp; t \u0026lt;= r) return d[p]; // 当前区间为询问区间的子集时直接返回当前区间的和 int m = s + ((t - s) \u0026gt;\u0026gt; 1), sum = 0; if (l \u0026lt;= m) sum += getsum(l, r, s, m, p * 2); // 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子 if (r \u0026gt; m) sum += getsum(l, r, m + 1, t, p * 2 + 1); // 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子 return sum; } 线段树的区间修改与懒惰标记 过程 如果要求修改区间 $[l,r]$，把所有包含在区间 $[l,r]$ 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 「lazy标记」 的东西。\nlazy标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。\n仍然以最开始的图为例，我们将执行若干次给区间内的数加上一个值的操作。我们现在给每个节点增加一个 $t_i$，表示该节点带的标记值。\n现在我们准备给 $[3,5]$ 上的每个数都加上 $5$。根据前面区间查询的经验，我们很快找到了两个极大区间 $[3,3]$ 和 $[4,5]$（分别对应线段树上的 $3$ 号点和 $5$ 号点）。\n我们直接在这两个节点上进行修改，并给它们打上标记：\n我们发现，$3$ 号节点的信息虽然被修改了（因为该区间管辖两个数，所以 $d_3$ 加上的数是 $5*2=10$），但它的两个子节点却还没更新，仍然保留着修改之前的信息。不过不用担心，虽然修改目前还没进行，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。\n接下来我们查询一下 $[4,4]$ 区间上各数字的和。\n我们通过递归找到 $[4,5]] 区间，发现该区间并非我们的目标区间，且该区间上还存在标记。这时候就到标记下放的时间了。我们将该区间的两个子区间的信息更新，并清除该区间上的标记。\n现在 $6$、$7$ 两个节点的值变成了最新的值，查询的结果也是准确的。\n实现 区间修改（加值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void update(int l, int r, int c, int s, int t, int p) { // [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p // 为当前节点的编号 if (l \u0026lt;= s \u0026amp;\u0026amp; t \u0026lt;= r) { d[p] += (t - s + 1) * c, b[p] += c; return; } // 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改 int m = s + ((t - s) \u0026gt;\u0026gt; 1); if (b[p] \u0026amp;\u0026amp; s != t) { // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值 d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m); b[p * 2] += b[p], b[p * 2 + 1] += b[p]; // 将标记下传给子节点 b[p] = 0; // 清空当前节点的标记 } if (l \u0026lt;= m) update(l, r, c, s, m, p * 2); if (r \u0026gt; m) update(l, r, c, m + 1, t, p * 2 + 1); d[p] = d[p * 2] + d[p * 2 + 1]; } 区间查询（求和）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int getsum(int l, int r, int s, int t, int p) { // [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号 if (l \u0026lt;= s \u0026amp;\u0026amp; t \u0026lt;= r) return d[p]; // 当前区间为询问区间的子集时直接返回当前区间的和 int m = s + ((t - s) \u0026gt;\u0026gt; 1); if (b[p]) { // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值 d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m); b[p * 2] += b[p], b[p * 2 + 1] += b[p]; // 将标记下传给子节点 b[p] = 0; // 清空当前节点的标记 } int sum = 0; if (l \u0026lt;= m) sum = getsum(l, r, s, m, p * 2); if (r \u0026gt; m) sum += getsum(l, r, m + 1, t, p * 2 + 1); return sum; } 动态开点线段树 前面讲到堆式储存的情况下，需要给线段树开 $4n$ 大小的数组。为了节省空间，我们可以不一次性建好树，而是在最初只建立一个根结点代表整个区间。当我们需要访问某个子区间时，才建立代表这个区间的子结点。这样我们不再使用 $2p$ 和 $2p+1$ 代表 $p$ 结点的儿子，而是用 $ls$ 和 $rs$ 记录儿子的编号。总之，动态开点线段树的核心思想就是：结点只有在有需要的时候才被创建。\n单次操作的时间复杂度是不变的，为 $O(logn)$。由于每次操作都有可能创建并访问全新的一系列结点，因此 m 次单点操作后结点的数量规模是 $O(mlogn)$。最多也只需要 $2n-1$ 个结点，没有浪费。\n实现 单点修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // root 表示整棵线段树的根结点；cnt 表示当前结点个数 int n, cnt, root; int sum[n * 2], ls[n * 2], rs[n * 2]; // 用法：update(root, 1, n, x, f); 其中 x 为待修改节点的编号 void update(int\u0026amp; p, int s, int t, int x, int f) { // 引用传参 if (!p) p = ++cnt; // 当结点为空时，创建一个新的结点 if (s == t) { sum[p] += f; return; } int m = s + ((t - s) \u0026gt;\u0026gt; 1); if (x \u0026lt;= m) update(ls[p], s, m, x, f); else update(rs[p], m + 1, t, x, f); sum[p] = sum[ls[p]] + sum[rs[p]]; // pushup } 区间询问\n1 2 3 4 5 6 7 8 9 // 用法：query(root, 1, n, l, r); int query(int p, int s, int t, int l, int r) { if (!p) return 0; // 如果结点为空，返回 0 if (s \u0026gt;= l \u0026amp;\u0026amp; t \u0026lt;= r) return sum[p]; int m = s + ((t - s) \u0026gt;\u0026gt; 1), ans = 0; if (l \u0026lt;= m) ans += query(ls[p], s, m, l, r); if (r \u0026gt; m) ans += query(rs[p], m + 1, t, l, r); return ans; } 区间修改也是一样的，不过下放标记时要注意如果缺少孩子，就直接创建一个新的孩子。或者使用标记永久化技巧。\n优化 在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。 标记永久化技巧 如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。 进阶 - 猫树 众所周知线段树可以支持高速查询某一段区间的信息和，比如区间最大子段和，区间和，区间矩阵的连乘积等等。\n但是有一个问题在于普通线段树的区间询问在某些毒瘤的眼里可能还是有些慢了。\n简单来说就是线段树建树的时候需要做 $O(n)$ 次合并操作，而每一次区间询问需要做 $O(logn)$ 次合并操作，询问区间和这种东西的时候还可以忍受，但是当我们需要询问区间线性基这种合并复杂度高达 $O(log^2\\omega)$ 的信息的话，此时就算是做 O(logn) 次合并有些时候在时间上也是不可接受的。\n线性基是一个数的集合，并且每个序列都拥有至少一个线性基，取线性基中若干个数异或起来可以得到原序列中的任何一个数。\n而所谓“猫树”就是一种不支持修改，仅仅支持快速区间询问的一种静态线段树。 构造一棵这样的静态线段树需要 $O(nlogn)$ 次合并操作，但是此时的查询复杂度被加速至 $O(1)$ 次合并操作。\n在处理线性基这样特殊的信息的时候甚至可以将复杂度降至 $O(nlog^2\\omega)$。\n原理 在查询 $[l,r]$ 这段区间的信息和的时候，将线段树树上代表 $[l,l]$ 的节点和代表 $[r,r]$ 这段区间的节点在线段树上的 LCA 求出来，设这个节点 $p$ 代表的区间为 $[L,R]$，我们会发现一些非常有趣的性质：\n$[L,R]$这个区间一定包含 $[l,r]$。显然，因为它既是 $l$ 的祖先又是 $$ 的祖先。 $[l,r]$这个区间一定跨越 $[L,R]$ 的中点。由于 $p$ 是 $l$ 和 $r$ 的 LCA，这意味着 $p$ 的左儿子是 $l$ 的祖先而不是 $r$ 的祖先，$p$ 的右儿子是 $r$ 的祖先而不是 $l$ 的祖先。因此，$l$ 一定在 $[L,mid]$ 这个区间内，$r$ 一定在 $[mid,R]$ 这个区间内。 有了这两个性质，我们就可以将询问的复杂度降至 $O(1)$ 了。 实现 具体来讲我们建树的时候对于线段树树上的一个节点，设它代表的区间为 $(l,r]$。\n不同于传统线段树在这个节点里只保留 $[l,r]$ 的和，我们在这个节点里面额外保存 $(l,mid]$ 的后缀和数组和 $(mid,r]$ 的前缀和数组。\n这样的话建树的复杂度为 $T(n)=2T(n/2)+O(n)=O(nlogn)$ 同理空间复杂度也从原来的 $O(n)$ 变成了 $O(nlogn)$。\n下面是最关键的询问了。\n如果我们询问的区间是 $[l,r]$ 那么我们把代表 $[l,l]$ 的节点和代表 $[r,r]$ 的节点的 LCA 求出来，记为 $p$。\n根据刚才的两个性质，$l,r$ 在 $p$ 所包含的区间之内并且一定跨越了 $p$ 的中点。\n这意味这一个非常关键的事实是我们可以使用 $p$ 里面的前缀和数组和后缀和数组，将 $[l,r]$ 拆成 $[l,mid]+(mid,r]$ 从而拼出来 $[l,r]$ 这个区间。\n而这个过程仅仅需要 $O(1)$ 次合并操作！\n当然如何求LCA，已经在这上面的优化，这次就不说。\n","permalink":"https://eveneko.com/posts/algorithm-tutorial/segemnt-tree/","summary":"例题 已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 k 求出某区间每一个数的和。 引入 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。 线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 条件 线段树维护的信息可以认为","title":"线段树(Segment Tree)入门"},{"content":"本页面收录和车辆固件在模拟环境下模糊测试相关的论文。(43篇)\nAll Papers(Classification according to Subject) Survey/Review Detecting Vulnerability on IoT Device Firmware: A Survey (2022) {% spoiler more %} 物联网 (IoT) 设备占所有网络连接端点的 30%，引入了漏洞和新颖的攻击，使许多公司成为网络犯罪分子的主要目标。为了应对这种日益增加的威胁面，每个部署物联网设备的组织都需要考虑安全风险，以确保这些设备的安全和可信。在所有安全风险解决方案中，固件安全分析对于修复软件错误、修补漏洞或添加新的安全功能以保护易受攻击设备的用户至关重要。然而，由于执行环境的多样性和固件的密切来源，固件安全分析从来都不是一件容易的事。这两个不同的功能使解压固件样本以进行详细分析的操作变得复杂。它们还使得创建视觉环境来模拟设备固件的运行变得困难。尽管研究人员在过去十年中开发了许多新方法来克服各种挑战，但在实践中，关键障碍阻碍了固件安全分析。因此，本次调查旨在系统地回顾和分析研究挑战及其解决方案，同时考虑广度和深度。具体来说，根据分析的角度，介绍了对物联网设备进行安全分析的各种方法，并将其分为四类。详细讨论了每个类别中的挑战，随后提出了潜在的解决方案。然后，我们讨论了这些解决方案的缺陷，并为该研究领域提供了未来的方向。包括软件开发人员、网络安全研究人员和软件安全工程师在内的广大读者可以利用本调查来更好地了解固件安全分析。 {% endspoiler %}\nFuzzing: A Survey for Roadmap (2022) {% spoiler more %} G.O.S.S.I.P 学术论文推荐 2022-02-28 Fuzzing: A Survey for Roadmap\n模糊测试(fuzzing)是近年来在安全法律检测领域兴起的一种方法。它生成大量的测试用例，并监视缺陷的执行。Fuzzing已经在各种应用程序中发现了数千个bug和漏洞。虽然有效，但缺乏对模糊所面临的空白的系统分析。模糊化作为一种缺陷检测技术，需要缩小整个输入空间与缺陷空间之间的差距。不限制生成的输入，输入空间是无限大的。然而，缺陷在应用程序中是稀疏的，这表明缺陷空间比整个输入空间小得多。此外，由于fuzzing会产生大量的测试用例来反复检查目标，因此需要fuzzing以自动的方式执行。由于应用程序的复杂性和缺陷，对不同应用程序的自动化执行具有挑战性。在本文中，我们从广度和深度两方面系统地回顾和分析了这些差距及其解决方案。这个调查可以成为初学者和高级开发人员更好地理解模糊的路线图。 {% endspoiler %}\nChallenges in Firmware Re-Hosting, Emulation, and Analysis (2021) {% spoiler more %} {% endspoiler %}\nA Review of Fuzzing Techniques (2021) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-1\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %} 模糊测试是一种安全测试技术,主要用于检测安全漏洞,近几年模糊测试技术经历了快速发展,因此有必要对相关成果进行总结和分析．通过搜集和分析网络与系统安全国际四大顶级安全会议(IEEES\u0026amp;P,USENIXSecurity,CCS,NDSS)中相关的文章,总结出模糊测试的基本工作流程,包括:预处理、输入数据构造、输入选择、评估、结果分析这５个环节,针对每个环节中面临的任务以及挑战,结合相应的研究成果进行分析和总结,其中重点分析以 American Fuzzy Lop 工具及其改进成果为代表的,基于覆盖率引导的模糊测试方法．模糊测试技术在不同领域中使用时,面对着巨大的差异性,通过对相应文献进行整理和分析,总结出特定领域中使用模糊测试的独特需求以及相应的解决方法,重点关注物联网领域,以及内核安全领域．近些年反模糊测试技术以及机器学习技术的进步,给模糊测技术的发展带来了挑战和机遇,这些机遇和挑战为下一步的研究提供了方向参考． {% endspoiler %}\nIoT Bugs and Development Challenges (2021) {% spoiler more %} 物联网系统迅速应用于各个领域，从嵌入式系统到智能家居。尽管物联网的采用和普及程度越来越高，但目前还没有深入的研究来从从业者的角度了解物联网发展面临的挑战。我们通过大规模的实证调查，首次系统地研究了物联网开发人员在实践中面临的bug和挑战。我们从91个具有代表性的物联网项目存储库中收集了5565个bug报告，并根据观察到的故障、根本原因和故障组件的位置对323个随机样本进行了分类。此外，我们对物联网专家进行了9次访谈，以揭示物联网bug的更多细节，并深入了解物联网开发人员面临的挑战。最后，我们调查了194名IoT开发人员，以验证我们的发现并获得进一步的见解。基于我们的研究结果，我们提出了物联网系统的第一个bug分类。我们强调了常见的bug类别及其根本原因、它们之间的相关性，以及物联网开发人员面临的常见陷阱和挑战。我们为需要关注的物联网领域推荐未来的发展方向。索引术语-物联网，软件工程，挖掘软件库，实证研究。 {% endspoiler %}\n嵌入式设备固件安全分析技术研究 (2021) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-5\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %}\n随着嵌入式设备的种类和数量的增加，设备之间日益增长的互联互通、制造商对安全的忽视、设备固件更 新不及时或难以更新等，使得嵌入式设备的安全受到了严峻的考验，越来越多的设备漏洞被披露．但由于嵌入式设 备种类繁多、专用性强、源码或设计文档往往不公开、运行环境受限等诸多因素的影响，通用漏洞挖掘技术无法直 接适配．近年来，国内外安全专家和学者针对嵌入式设备及其固件的安全分析和测评技术提出了很多切实可行的 解决方案，但缺乏详细和全面介绍最新安全研究成果的论文，使得安全分析人员难以系统地了解嵌入式设备及其 固件安全分析技术的研究进展．本文围绕着当前嵌入式设备固件面临的安全风险，分析和总结了国内外最新的研 究成果，并对相关安全技术进行了综合分析和评估．首先对嵌入式设备及其固件的表现形式、分类及获取方法、面 临的安全攻击层面以及自动化解析情况进行了深入研究．然后，对嵌入式设备固件安全分析技术进行了细化分析，从静态分析、符号执行、二进制漏洞关联、动态分析平台和模糊测试等五个方面进行了详细分析和横向评估．最后 对未来的研究方向进行了展望。 {% endspoiler %}\nFirmware Fuzzing: The State of the Art (2020) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-4\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %} 背景:固件是物联网设备的使能软件，其软件漏洞是物联网设备被利用的主要原因之一。由于物联网设备资源有限，部署复杂的运行时保护技术是不切实际的。在不安全的网络环境下，当固件被利用时，可能会导致拒绝服务、信息泄露、特权提升，甚至危及生命。因此，利用模糊技术进行固件漏洞检测已成为保障物联网设备安全的关键，也成为学术界和工业界研究的热点。随着现有物联网设备的快速增长、固件的规模和复杂性、固件类型的多样性以及固件的缺陷，现有的物联网固件模糊化方法面临挑战。 目的:总结物联网固件模糊化方法的典型类型，分析这些工作的贡献，总结现有模糊化方法的不足。 方法:设计几个研究问题，从研究问题中提取关键词，利用关键词检索相关文献。 结果:根据固件的执行环境，我们将现有的固件模糊化工作分为基于真实设备的模糊化和基于仿真的模糊化，基于仿真的模糊化是未来的主流;我们发现现有模糊化方法主要针对的漏洞类型为内存破坏漏洞;固件模糊比普通软件模糊困难得多。 结论:通过分析不同方法的优缺点，本文为进一步提高模糊化技术的性能提供了指导，并根据本文的研究结果提出了几点建议。 {% endspoiler %}\nFuzzing: State of the Art (2018) {% spoiler more %} 模糊测试(fuzzing)是目前最流行的软件测试技术之一，它通过生成大量的测试输入，可以发现程序中的各种弱点，如软件bug和漏洞。由于其有效性，模糊被认为是一种有价值的bug搜索方法。在这篇论文中，我们提出了模糊化的概述，集中在其一般过程，以及分类，随后详细讨论了关键障碍和一些旨在克服或减轻这些障碍的最先进的技术。我们进一步研究和分类了几种广泛使用的模糊工具。我们的主要目标是让涉众更好地理解模糊，以及在软件测试和安全范围内改进模糊方法的潜在解决方案。为了启发未来的研究，我们还预测了模糊化的一些未来方向。 {% endspoiler %}\nThe Art, Science, and Engineering of Fuzzing: A Survey (2018) {% spoiler more %} 在当今可用的许多软件漏洞发现技术中，模糊分析由于其概念上的简单性、部署的低门槛以及在发现真实软件漏洞方面的大量经验证据而一直非常受欢迎。在较高的层次上，模糊是指重复运行程序的过程，所生成的输入可能在语法或语义上有缺陷。近年来，研究人员和从业人员都投入了大量和多样化的努力来改善模糊化，但这一工作的激增也使人们难以获得关于模糊化的全面和连贯的观点。为了帮助保持和使大量模糊化文献保持连贯性，本文提出了一个统一的、通用的模糊化模型，并对当前模糊化文献进行了分类。我们系统地探索模型模糊器每个阶段的设计决策，通过调查艺术、科学和工程方面的相关文献和创新，使现代模糊器有效。 {% endspoiler %}\nGeneral Fuzzing LibAFL: A Framework to Build Modular and Reusable Fuzzers (2022) {% spoiler more %} G.O.S.S.I.P 阅读推荐 2022-08-24 LibAFL AFL的发布标志着软件安全测试领域的一个重要里程碑，重新激活了fuzzing作为一个主要的研究课题，并激发了大量试图改进和评估fuzzing管道不同方面的研究。许多这样的研究通过AFL代码库分叉来实现他们的技术。虽然这个选择乍一看似乎是合适的，但将多个分叉组合成一个模糊器需要很高的工程开销，这将阻碍该领域的进展，并阻止对不同技术的公平和客观的评估。模糊生态系统的高度碎片化景观也阻止了研究人员结合正交技术，并使最终用户难以采用新的原型解决方案。为了解决这一问题，本文提出了一种模块化、可重用的模糊信号处理框架LibAFL。我们讨论了模糊处理中通常使用的不同组件，并将它们映射到一个可扩展的框架。LibAFL允许研究人员和工程师扩展核心模糊器管道，并为进一步评估共享他们的新组件。作为LibAFL的一部分，我们集成了20多个以前工作的技术，并进行了广泛的实验，以展示我们的框架在结合和评估不同方法方面的好处。我们希望这能帮助阐明当前模糊化的进展，并为未来的比较和可扩展的研究提供一个坚实的基础。 {% endspoiler %}\nFirmware Fuzzing Fuzzware: Using Precise MMIO Modeling for Effective Firmware Fuzzing (2022) {% spoiler more %} 随着嵌入式设备在我们的日常生活中越来越普遍，它们成为对手的一个诱人的目标。尽管它们具有很高的价值和较大的攻击面，但应用自动化测试技术(如模糊)对这类设备并不是很直接。由于在受限的嵌入式设备上对固件进行模糊测试效率低下，最先进的方法反而选择在模拟器中运行固件(通过一个称为重新托管的过程)。然而，现有的方法要么使用粗粒度的硬件行为静态模型，要么需要手工重新托管固件。我们提出了一种轻量级程序分析、重新托管和模糊测试的新组合来解决这些挑战。本文提出了一种软件专用系统FUZZWARE的设计与实现方法，该系统能够以一种可扩展的方式对未修改的单片固件进行模糊测试。通过确定硬件生成的值是如何被固件逻辑实际使用的，FUZZWARE可以自动生成模型，帮助将模糊处理集中在改变重要的输入上，这大大提高了它的效率。我们在包括19个硬件平台和77个固件图像的合成目标和真实目标上评估我们的方法。与最先进的工作相比，FUZZ-WARE实现了高达3.25倍的代码覆盖率，我们的建模方法减少了高达95.5%的输入空间的大小。合成样本包含66个针对各种硬件交互的单元测试，我们发现我们的方法是第一个自动通过所有单元测试的通用重新托管解决方案。FUZZWARE发现了15个全新的bug，包括其他作品之前分析的目标bug;总共分配了12个cve。 {% endspoiler %}\nFIRM-COV: High-Coverage Greybox Fuzzing for IoT Firmware via Optimized Process Emulation (2021) {% spoiler more %} 随着物联网(IoT)的日益普及，相关的安全威胁也随之增加。动态检测物联网设备漏洞的必要性再怎么强调也不为过。在这项工作中，我们提出了FIRM-COV，这是第一个面向物联网固件的高覆盖率灰盒模糊器。FIRMCOV通过针对物联网程序和挖掘真实世界漏洞，利用最新优化的流程模拟。基于经验分析，利用结构化输入、仿真的不准确性和不稳定性以及对代码覆盖率的要求，致力于解决物联网模糊化问题。通过优化现有的仿真技术，FIRM-COV在检测漏洞时始终保持稳定状态，准确率较高。我们还实现字典生成算法，以提供结构化的输入值和协同调度，以实现高覆盖率和吞吐量。我们将FIRM-COV与其他针对8个真实物联网设备的物联网模糊框架进行比较。因此，FIRM-COV实现了最高的覆盖率和吞吐量，发现了最快和最多的1天漏洞，几乎没有误报。它还在24小时内发现了现实物联网设备中的两个0天漏洞。 {% endspoiler %}\nDIANE: Identifying Fuzzing Triggers in Apps to Generate Under-constrained Inputs for IoT Devices (2021) {% spoiler more %} 物联网(IoT)设备已经根植于数十亿人的日常生活中。因此，研究人员已经应用自动bug查找技术来提高整体安全性。然而，由于提取和模拟自定义固件的困难，黑盒模糊往往是唯一可行的分析选择。不幸的是，这种解决方案大多会产生无效输入，这些输入会被目标物联网设备迅速丢弃，并且无法穿透其代码。另一种建议的方法是利用配套应用程序(即通常用于控制物联网设备的移动应用程序)来生成结构良好的模糊输入。不幸的是，现有的解决方案产生的模糊输入受到应用程序端验证代码的限制，从而大大限制了发现的漏洞的范围。在本文中，我们提出了一种新的方法来克服这些限制。我们的关键观察是，在配套的应用程序中存在可用于生成最佳(即有效但不受约束)模糊输入的函数。这样的函数，我们称之为模糊触发器，在任何数据转换函数(例如，网络序列化)之前执行，但在输入验证代码之后执行。因此，它们生成的输入不受应用端消毒代码的约束，同时，也不会因其格式无效而被分析的物联网设备丢弃。我们设计和开发了一款结合静态和动态分析的工具，在Android配套应用中寻找模糊触发点，然后使用它们自动模糊物联网设备。我们使用DIANE分析了11个流行的物联网设备，并识别了11个bug，其中9个是零天。我们的结果还表明，如果不使用模糊触发，就不可能为许多设备生成错误触发输入。 {% endspoiler %}\nFIRMNANO: Toward IoT Firmware Fuzzing Through Augmented Virtual Execution (2020) {% spoiler more %} 考虑到物联网设备的部署越来越广泛，这些设备的固件的安全分析是极其重要的。然而，现在大量的设备都存在漏洞，攻击者可以利用这些漏洞远程控制物联网设备。在本文中，我们展示了FIRMNANO，一个以微控制器为核心的fiot设备固件模糊化框架。FIRMNANO基于增强的虚拟执行，解决了微控制器固件仿真的三个关键问题:(1)MMIO区域访问(2)中断触发(3)DMA支持。在此基础上，对固件进行了基于代码覆盖的模糊测试。我们的评估结果表明，FIRMNANO可以正确地执行固件，并可用于真实的固件漏洞挖掘。 {% endspoiler %}\nEM-Fuzz: Augmented Firmware Fuzzing via Memory Checking (2020) {% spoiler more %} 在新兴的应用场景中，嵌入式系统的互联程度越来越高。这些应用程序中的许多都对安全至关重要，因此，确保系统免受恶意攻击是非常重要的。这项工作的目的是检测嵌入式固件中的漏洞，这些漏洞可能被对手利用来破坏功能的正确性，这是具有挑战性的，特别是由于缺乏源代码。特别地，我们提出EM-Fuzz，这是一种固件漏洞检测技术，它将fuzzing与实时内存检查紧密地集成在一起。基于内存检测的固件模糊化不仅可以通过传统的分支覆盖来引导生成高质量的种子来探测难以到达的区域，还可以通过记录的内存敏感操作来连续地锻炼容易被攻击的敏感区域。更重要的是，该检测集成了实时内存检查器来暴露内存漏洞，这是现有的没有源代码的模糊器所不能很好地支持的。在几个真实世界的嵌入式固件(如OpenSSL)上的实验表明，EM-Fuzz显著提高了最先进的模糊工具(如AFL和AFLFast)的性能，覆盖率分别提高了93.98%和46.89%。此外，EM-Fuzz总共暴露了23个漏洞，每个漏洞平均耗时约7小时。AFL和AFLFast总共发现了10个漏洞，平均每个漏洞花费的时间分别为13小时和10小时。在这23个漏洞中，有16个以前是未知的，并且已经报告给了上游产品供应商，其中7个在美国国家漏洞数据库中被分配了唯一的CVE标识符。 {% endspoiler %}\nFw-fuzz: A code coverage-guided fuzzing framework for network protocols on firmware (2020) {% spoiler more %} 模糊化是一种利用可变生成输入检测软件漏洞的有效方法。然而，在物联网设备的固件上模糊网络协议受到测试用例生成、跨架构检测和故障检测效率低的限制。在本文中，我们提出了Fw-fuzz，这是一个覆盖引导的跨平台框架，用于模糊在嵌入式体系结构上的固件上下文中运行的网络服务，它可以通过内省程序运行时信息和使用遗传算法模型生成更多有价值的测试用例。具体地说，我们在Fw-fuzz中提出了新颖的动态工具来收集固件程序的运行状态。Fw-fuzz采用一种遗传算法模型指导代码覆盖率高的输入生成。我们全面实现了Fw-fuzz的原型系统，并对MIPS、ARM、PPC等多种架构的网络服务程序进行了评估。通过与协议模糊器Boofuzz和Peach在边缘覆盖指标方面的比较，我们的原型系统分别获得了33.7%和38.4%的平均增长率。我们进一步验证了6个已知的漏洞，并利用Fw-fuzz发现了5个0天漏洞，证明了我们的框架的有效性和实用性。我们系统的开销表示为内存增长的额外5%。 {% endspoiler %}\nFIRMCORN: Vulnerability-Oriented Fuzzing of IoT Firmware via Optimized Virtual Execution (2020) {% spoiler more %} 物联网(IoT)的安全形势尤为严峻，大量物联网设备容易出现漏洞。在本研究中，我们提出了第一个面向漏洞的物联网固件模糊器FIRMCORN。基于优化虚拟执行的新技术，FIRMCORN重点研究了物联网固件模糊化的三个典型问题:(1)模糊化需要高吞吐量;(2)仿真与真实设备相比不准确;(3)缺乏硬件导致的仿真不稳定。在这里，我们优化了虚拟执行的初始环境和执行过程，以实现更快、更准确、更稳定的模糊测试。为提高fircorn漏洞挖掘的效率，根据物联网固件的特点，设计了一种漏洞代码搜索算法，获取模糊化入口点;此外，这种面向漏洞的模糊处理应用于物联网设备固件。我们的评估结果表明，与传统虚拟执行相比，fircorn使用的优化虚拟执行可以显著提高吞吐量、准确性和稳定性。FIRMCORN只运行2小时，就能在一台机器上挖掘出两个0天的漏洞。因此，与目前最先进的物联网固件模糊化框架相比，FIRMCORN可以更有效地挖掘现实设备中的漏洞。 {% endspoiler %}\nFirmFuzz: Automated IoT Firmware Introspection and Analysis (2019) {% spoiler more %} 虽然物联网设备的数量以令人振奋的速度增长，但其安全性却停滞不前。在所有供应商之间强制执行安全编码标准是不可行的。测试单个设备可以让分析师评估其部署后的安全性。然后可以向供应商披露任何发现的漏洞，以帮助他们保护其产品。为了提高效率，理想情况下应该自动查找漏洞，而且为了提高可伸缩性，应该独立于设备。我们提出了一个用于基于linux的固件映像的自动化设备无关仿真和动态分析框架FirmFuzz。它使用基于灰盒的分代模糊方法，并结合静态分析和系统内省，在固件映像中提供有针对性的、确定性的bug发现。我们通过模拟和动态分析32个图像(来自27个独特的设备)来评估FirmFuzz，网络可从执行模拟的主机访问。在测试过程中，FirmFuzz在6个不同的设备上发现了7个之前未披露的漏洞:两个IP摄像头和4个路由器。到目前为止，已经分配了4个CVE。 {% endspoiler %}\nWhat You Corrupt Is Not What You Crash: Challenges in Fuzzing Embedded Devices (2018) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-2\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %}\n随着网络化嵌入式系统越来越普遍，其安全性对我们的日常生活变得至关重要。虽然对这些系统进行手动或自动化的大规模分析会定期发现新的漏洞，但分析这些系统的方法通常与桌面系统中使用的方法相同。更具体地说，传统的测试方法依赖于可观察到的程序崩溃，二进制检测技术用于改进对这些错误状态的检测。 在本文中，我们演示了内存损坏(一种常见的安全漏洞)在嵌入式设备上导致的行为通常与桌面系统不同。特别是，在嵌入式设备上，内存损坏的影响通常不太明显。这大大降低了传统动态测试技术的有效性，特别是模糊。 此外，我们分析了几类嵌入式设备中的这些差异，并展示了对固件分析的结果影响。我们进一步描述和评估可以在运行时(在执行跟踪或在模拟器中)应用的相对简单的启发式方法，在分析嵌入式设备时检测以前未检测到的内存损坏。 {% endspoiler %}\nReal Device A Runtime Verification Tool for Detecting Concurrency Bugs in FreeRTOS Embedded Software (2018) {% spoiler more %} 本文介绍了一种用于嵌入式软件在开源实时操作系统FreeRTOS下运行的运行时验证工具。该工具可以检测和诊断并发bug，如死锁、饥饿和基于挂起的锁。该工具在运行时发现并发错误，而不需要调试和跟踪源代码。该工具使用Tracealyzer工具记录相关事件。通过分析日志，我们的工具可以通过应用单独诊断每种并发性bug类型的算法来检测并发性bug。 在本文中，我们介绍了该工具的实现，以及它的功能架构，并说明了它的使用。该工具可以在程序测试期间使用，以获得关于嵌入式软件执行的有趣信息。我们展示了在AVR 32位板SAM4S上运行该工具的一些典型bug示例的初始结果。 {% endspoiler %}\nIoTFuzzer: Discovering Memory Corruptions in IoT Through App-based Fuzzing (2018) {% spoiler more %} 随着越来越多的物联网设备进入消费市场，在攻击者之前检测它们的安全漏洞变得势在必行。现有的基于二进制分析的方法只在固件上工作，这是比较难访问的，除非那些配备了从设备提取代码的特殊工具。为了解决物联网安全分析中的这一挑战，我们在本文中提出了一种新的自动模糊化框架，称为IOTFUZZER，旨在发现在无法访问其固件映像的物联网设备中的内存破坏漏洞。其关键思想是基于这样一种观察，即大多数物联网设备都是通过其官方移动应用程序控制的，而这样的应用程序通常包含有关其用于与设备通信的协议的丰富信息。因此，通过识别和重用特定于程序的逻辑(例如，加密)来改变测试用例(特别是消息字段)，我们能够有效地探测物联网目标，而无需依赖任何关于其协议规范的知识。在我们的研究中，我们实现了iotfuzzer，并评估了17个运行在不同协议上的真实IoT设备，我们的方法成功识别了15个内存破坏漏洞(包括8个之前未知的漏洞)。 {% endspoiler %}\nRPFuzzer: A Framework for Discovering Router Protocols Vulnerabilities Based on Fuzzing (2013) {% spoiler more %} 如何有效、自动地发现路由器漏洞是保障网络和信息安全的关键问题。以往对路由器安全的研究主要集中在利用路由器已知缺陷的技术上。Fuzzing是一种著名的自动化漏洞发现技术;然而，传统的Fuzzing工具是为测试网络应用或其他软件而设计的。这些工具不适合或部分不适合测试路由器。本文设计了一个发现路由器协议漏洞的框架，并在已有的测试用例生成方法的基础上，提出了一个两阶段模糊测试用例生成器(TFTCG)的数学模型。我们开发了一个基于TFTCG的RPFuzzer工具。RPFuzzer通过发送正常的数据包、监视CPU利用率和检查系统日志来监控路由器，这些日志可以检测到DoS、路由器重启等。基于修改的Dynamips的RPFuzzer\u0026rsquo;调试器，它可以在发生异常时记录寄存器值。最后，我们在SNMP协议上进行实验，发现了8个漏洞，其中有5个未发布的漏洞。实验证明了该方法的有效性。 {% endspoiler %}\nEmulator FirmAE: Towards Large-Scale Emulation of IoT Firmware for Dynamic Analysis (2020) {% spoiler more %} FIRMADYNE改良 评估嵌入式物联网设备安全性的一种方法是对其固件进行动态分析，如模糊测试。为此，现有的方法旨在提供一个模拟真实硬件/外设行为的模拟环境。尽管如此，在实践中，这些方法只能模拟固件映像的一小部分。例如，我们从八大制造商那里收集到的1124张无线路由器/ ip摄像头图像中，最先进的工具Firmadyne只能显示183张(16.28%)。如此低的仿真成功率是由于真实的固件执行环境和仿真的固件执行环境不一致造成的。在本研究中，我们分析了大规模数据集中的模拟失败案例，以找出导致模拟率低的原因。我们发现，尽管根本原因不同，但使用简单的启发式方法往往可以避免广泛的故障情况，从而显著提高模拟的成功率。基于这些发现，我们提出了一种技术，仲裁模拟，并将几种启发式技术系统化，作为仲裁技术来解决这些故障。我们的自动化原型FirmAE成功地运行了1124个固件映像中的892个(79.36%)，其中包括web服务器，这比Firmadyne运行的映像多了很多(≈4.8倍)。最后，通过对仿真图像应用动态测试技术，FirmAE可以检测320个已知漏洞(比Firmadyne多306个)，并在23个设备中发现12个新的0天漏洞。 {% endspoiler %}\nFIRM-AFL: high-throughput greybox fuzzing of iot firmware via augmented process emulation (2019) {% spoiler more %} FIRMADYNE改良 针对物联网设备的网络攻击是一个严重的威胁。这些攻击利用了物联网固件的软件漏洞。摸索是一种有效的软件测试技术，用于发现漏洞。在这项工作中，我们提出了FIRM-AFL，这是第一个用于物联网固件的高通量灰盒模糊器。FIRM-AFL解决了物联网模糊测试的两个基本问题。首先，它通过对POSIX兼容的固件进行模糊处理来解决兼容性问题，这些固件可以在系统仿真器中模拟。其次，它通过一种称为增强进程仿真的新技术解决了系统模式仿真造成的性能瓶颈问题。通过将系统模式仿真和用户模式仿真以一种新颖的方式结合起来，增强的进程仿真提供了系统模式仿真的高兼容性和用户模式仿真的高吞吐量。我们的评估结果显示：（1）FIRM-AFL功能齐全，能够发现物联网程序中的真实漏洞；（2）FIRM-AFL的吞吐量平均比基于系统模式仿真的模糊测试高8.2倍；（3）FIRM-AFL能够比基于系统模式仿真的模糊测试更快地发现1天的漏洞，并且能够发现0-day的漏洞。 {% endspoiler %}\nTowards Automated Dynamic Analysis for Linux-based Embedded Firmware (2016) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-3\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %} 商用现货(COTS)网络支持的嵌入式设备通常由供应商固件控制，在我们的日常生活中执行不可或缺的功能。例如，家庭无线路由器通常是将家庭用户的个人计算和信息设备与互联网隔离开来的第一道也是唯一一道防线。在用户网络中这样一个至关重要的特权位置要求这些设备安全地运行。不幸的是，最近的研究和传闻证据表明，世界各地部署的设备根本不支持这种安全假设。 评估此类嵌入式设备固件安全性的第一步是准确识别漏洞。然而，市场提供了各种各样的嵌入式设备，这严重影响了该领域现有方法的可扩展性。在本文中，我们提出了FIRMADYNE，这是第一个自动化的动态分析系统，以可伸缩的方式专门针对网络连接COTS设备上基于linux的固件。我们确定了一系列固有于COTS固件动态分析的挑战，并讨论了我们的设计决策如何解决它们。在其核心，FIRMADYNE依赖于基于软件的完整系统模拟和一个仪表化内核，以实现自动分析数千个固件二进制文件所需的可伸缩性。 我们通过收集42家设备供应商的23,035个固件图像的真实数据集，对FIRMADYNE进行了评估。使用我们的系统可以成功提取的9486个固件映像上的74个漏洞样本，我们发现跨越至少89个不同产品的887个固件映像容易受到一个或多个采样漏洞的攻击。其中包括在我们的框架帮助下发现的14个以前未知的漏洞，这些漏洞影响至少12个不同产品的69个固件映像。此外，我们的结果显示，我们测试的11次攻击影响了来自多个供应商的固件映像，这表明代码共享和通用上游制造商(oem)非常普遍。 {% endspoiler %}\nHardware-in-the-loop（HITL） Avatar2: A Multi-target Orchestration Platform (2018) {% spoiler more %} 动态二进制分析技术在研究软件系统的安全性和检测广泛的设备和应用中的漏洞方面发挥着核心作用。在过去的十年中，已经发布了各种不同的技术，通常伴随着原型工具的发布来证明它们的有效性。不幸的是，这些技术的大多数实现都与它们的动态分析框架深度耦合，并且不容易集成到其他框架中。这些框架的设计目的不是向其他组件公开它们的内部状态或结果。这使得分析人员无法将不同的工具组合在一起，以利用它们的优势并解决需要复杂技术组合的复杂问题。碎片化和隔离是两个非常重要的问题，它们常常导致对同一问题的重复工作或多个等效解决方案——每个解决方案都基于不同的编程语言、抽象模型或执行环境。 在本文中，我们提出了avatar2，一个动态多目标编制框架，旨在实现不同动态二进制分析框架、调试器、模拟器和真实物理设备之间的互操作性。Avatar2允许分析师在复杂的拓扑结构中组织不同的工具，然后将二进制代码的执行从一个系统“移动”到另一个系统。该框架支持设备/应用程序内部状态的自动传输，以及对物理外设或模拟目标的输入/输出和内存访问的可配置转发。 为了演示avatar2的使用和通用性，在本文中，我们展示了三个非常不同的用例，其中我们复制了一个在NDSS 2017上展示的PLC rootkit，我们结合Angr和GDB测试Firefox，我们使用PANDA和OpenOCD记录嵌入式设备固件的执行情况。所有的工具和三个用例将作为开源发布，以帮助其他研究人员复制我们的实验，并使用avatar2执行他们自己的分析任务。 {% endspoiler %}\nSURROGATES: Enabling Near-Real-Time Dynamic Analyses of Embedded Systems (2015) {% spoiler more %} 嵌入式系统正变得越来越复杂、相互连接和普及。不幸的是，保护这些系统仍然具有挑战性。虽然已经为传统软件开发了强大的动态分析工具，但嵌入式系统的独特特性使这些众所周知的技术难以应用;以前的工作仅限于小系统或短代码段。在本文中，我们演示了一个系统，它能够在接近实时的情况下对嵌入式系统进行仿真和测量，使各种动态分析技术成为可能。我们的方法在主机的spci Express总线和被测系统之间使用一个定制的、低延迟的FPGA桥接器，允许模拟器完全访问系统的外设。这为模拟器提供了固件正常执行环境的真实表示，支持额外的动态分析技术，如concolic执行。我们讨论了设计决策和工程权衡，并根据之前的工作评估我们的系统。 {% endspoiler %}\nAVATAR: A framework to support dynamic security analysis of embedded systems\u0026rsquo; firmwares (2014) {% spoiler more %} 为了解决对嵌入式系统安全性日益增长的关注，对固件二进制文件进行准确的分析是很重要的，即使在源代码或硬件文档不可用的情况下。然而，由于缺乏专门的研究工具，这一领域的研究受到了阻碍。例如，动态分析是安全分析的主要基础之一，例如，通过动态污染跟踪或符号执行。与静态分析不同，动态分析依赖于在受控环境中执行软件的能力，通常是一个仪表化的模拟器。然而，模拟嵌入式设备的固件需要被分析的系统所使用的所有硬件组件的精确模型。不幸的是，缺乏文档和市场上各种各样的硬件使得这种方法在实践中不可行。 在这篇文章中，我们提出了Avatar，一个通过协调模拟器和真实硬件的执行来实现嵌入式设备复杂动态分析的框架。首先介绍了将I/O访问从模拟器转发到嵌入式设备的基本机制，然后描述了通过动态优化两种环境之间的代码和数据分布来提高系统性能的几种技术。最后，我们通过将其应用于三种不同的安全场景来评估我们的工具，包括反向工程、漏洞发现和硬编码后门检测。为了展示Avatar的灵活性，我们在三个完全不同的设备上进行分析:GSM功能手机、硬盘引导加载程序和无线传感器节点。 {% endspoiler %}\nRe-hosting Automatic Firmware Emulation through Invalidity-guided Knowledge Inference (2021) {% spoiler more %} G.O.S.S.I.P 学术论文推荐 2022-01-19 uEmu 由于硬件和固件之间的紧密耦合，对微控制器进行固件仿真具有挑战性。这极大地阻碍了动态分析工具在固件分析中的应用。最先进的工作是通过观察未知外设的访问模式来自动建模，然后利用启发式来计算当未知外设寄存器被访问时的适当响应。但是，我们根据经验发现，这种方法和相应的启发式方法通常不足以模拟固件。在这项工作中，我们提出了一种新的方法，称为μEmu来模拟固件与未知的外设。与试图为每个外设构建通用模型的现有工作不同，我们的方法学习如何正确地模拟在各个外设访问点上的固件执行。它将图像作为输入，并通过将未知的外围寄存器表示为符号来象征性地执行它。在符号执行期间，它推断出响应未知外设访问的规则。这些规则存储在一个知识库中，在动态固件分析期间将引用该知识库。μEmu在外设驱动程序单元测试中，在没有任何人工辅助的情况下，达到93%的通过率。我们还用真实的固件样本评估μEmu，发现了新的bug。 {% endspoiler %}\nFirmGuide: Boosting the Capability of Rehosting Embedded Linux Kernels through Model-Guided Kernel Execution (2021) {% spoiler more %} Linux内核广泛应用于嵌入式系统中。为了理解对Linux内核的实际威胁，我们需要使用全系统模拟器(例如QEMU)执行动态分析。然而，由于硬件碎片化，例如各种类型的外设，QEMU目前不支持大多数嵌入式系统。虽然在重新托管固件方面取得了一些进展，但它主要集中在用户空间程序或简单的实时操作系统上。这项工作的目标是提高在QEMU中重新托管嵌入式Linux内核的能力。这样，通过利用QEMU上现成的工具，动态分析系统就可以首先应用于嵌入式Linux内核。因此，我们提出了一种称为模型引导内核执行的新技术。它结合了Linux内核中的外围设备抽象和内核-外围设备交互，以半自动生成外围设备模型，然后用这些模型合成新的QEMU虚拟机来启动动态分析。我们实现了一个名为FirmGuide的原型。它生成了9个功能完整的外围设备型号和64个最小功能覆盖26个soc。我们对6188个固件镜像的评估表明，它可以成功地在2个架构和22个版本中重新托管95%以上的Linux内核。它们都不能在普通的QEMU中重新托管。LTP基准测试的结果显示了重新托管的Linux内核的可靠性和健壮性。我们进一步在重新托管的Linux内核上执行两个安全应用程序，即漏洞分析和模糊处理，以演示使用场景。 {% endspoiler %}\nHALucinator: Firmware Re-hosting Through Abstraction Layer Emulation (2020) {% spoiler more %} 考虑到在线嵌入式设备的日益普及，分析其固件对安全性、隐私性和安全性非常重要。硬件和固件之间的紧密耦合以及嵌入式系统的多样性使固件难以进行动态分析。然而，固件开发人员经常使用抽象来开发代码，例如硬件抽象层(HALs)，以简化他们的工作。我们利用这些抽象作为重新托管和分析固件的基础。通过提供HAL功能的高级替换(称为高级仿真- HLE的过程)，我们将硬件与固件解耦。这种方法首先通过二进制分析定位固件示例中的库函数，然后在整个系统模拟器中提供这些函数的一般实现。 我们在一个原型系统HALucinator中提出了这些想法，该系统能够重新托管固件，并允许虚拟设备正常使用。首先，我们引入了对现有库匹配技术的扩展，这些技术需要在二进制固件中识别库函数，以减少冲突，并推断额外的函数名。接下来，我们将通过使用简化的处理程序和外围设备模型来演示重新托管过程，这将使该过程在固件样本和芯片供应商之间快速、灵活和可移植。最后，通过对HALucinator和美国Fuzzy Lop fuzzer进行补充，我们证明了HLE用于安全分析的实用性，以定位固件中间件库中先前未知的多个漏洞。 {% endspoiler %}\nDevice-agnostic Firmware Execution is Possible: A Concolic Execution Approach for Peripheral Emulation (2020) {% spoiler more %} 随着物联网设备的迅速普及，我们的网络空间如今由数十亿低成本的计算节点主导，这些节点彼此之间非常异构。动态分析是发现软件bug的最有效的方法之一，但由于缺乏能够运行各种以前看不到的固件的通用模拟器，动态分析已经陷入瘫痪。近年来，我们目睹了针对基于微控制器的低端物联网设备的破坏性安全漏洞。这些安全问题严重阻碍了物联网技术的进一步发展。在这项工作中，我们提出了Laelaps，一个专门设计的设备模拟器，以运行各种软件的微控制器设备。我们不会将任何关于设备的特定信息编码到模拟器中。相反，Laelaps通过符号执行辅助的外围模拟来推断固件的预期行为，并生成适当的输入来实时控制具体的执行。这种独特的设计特性使Laelaps能够运行不同的固件，而无需预先了解目标设备。为了演示Laelaps的功能，我们在模拟器上应用了动态分析技术。我们成功地识别了自我注入的和现实世界的漏洞。 {% endspoiler %}\nDICE: Automatic Emulation of DMA Input Channels for Dynamic Firmware Analysis (2020) {% spoiler more %} 基于微控制器的嵌入式设备是物联网(IoT)和信息物理系统(CPS)的核心。这些设备的安全至关重要。在保护嵌入式设备安全的方法中，动态固件分析(例如漏洞检测)由于其脱机特性和较低的假阳性率，最近受到了极大的关注。然而，无论使用何种分析和仿真技术，现有的动态固件分析器都有一个主要的限制，即无法使用DMA(直接内存访问)处理固件。它严重限制了支持的设备类型和固件代码覆盖范围。 我们提出了DICE，一种用于固件分析器模拟DMA输入通道和生成或操作DMA输入(从外设到固件)的临时解决方案。DICE被设计为独立于硬件(即不需要实际的外设或DMA控制器)，并兼容常见的MCU固件(即不假设特定于固件的DMA使用)和嵌入式架构。DICE背后的高级思想是识别和模拟抽象的DMA输入通道，而不是高度多样化的外围设备和控制器。当固件将源DMA传输指针和目标DMA传输指针写入DMA控制器时，DICE识别DMA输入通道。然后，DICE代表固件分析器操作通过DMA传输的输入。DICE不需要固件源代码或固件分析器提供的其他功能。 我们将DICE集成到最近提出的固件分析器P2IM(用于ARM Cortex-M架构)和PIC32模拟器(用于MIPS M4K/M-Class架构)。我们在83个基准测试和样本固件上评估了它，代表了来自5个不同供应商的9个不同的DMA控制器。DICE检测到37个DMA输入通道中的33个，0个假阳性。它正确地为固件实际使用的22个DMA缓冲区中的21个提供了DMA输入，这是由于缺乏DMA模拟，以前的固件分析器无法实现的。DICE的开销相当低，它平均增加了3.4%的P2IM执行时间。我们还使用DICE对7个真实世界的固件进行了模糊测试，并将结果与原始P2IM进行了比较。DICE发现了更多的执行路径(多达79X)，并发现了5个以前不知道的独特bug，这些bug在没有DMA模拟的情况下无法访问。我们所有的源代码和数据集都是公开的。 {% endspoiler %}\nP2IM: Scalable and Hardware-independent Firmware Testing via Automatic Peripheral Interface Modeling(2020) {% spoiler more %} 嵌入式固件的动态测试或模糊严重限制了硬件依赖和较差的可伸缩性，部分导致了普遍存在的脆弱的物联网设备。我们提出了一种软件框架，它可以持续地执行给定的固件二进制文件，同时从现成的模糊器引导输入，从而支持独立于硬件的、可扩展的固件测试。我们的框架使用了一种名为P2IM的新技术，对各种外设进行抽象，并根据自动生成的模型动态地处理固件I/O。P2IM与外围设备设计无关，与固件实现通用，因此适用于广泛的嵌入式设备。我们使用70个样本固件和10个来自真实设备(包括无人机、机器人和PLC)的固件来评估我们的框架。在没有任何人工协助的情况下，它成功地执行了79%的样本固件。我们还对真实的固件进行了有限的模糊测试，发现了7个独特的未知bug。 {% endspoiler %}\nToward the Analysis of Embedded Firmware through Automated Re-hosting (2019) {% spoiler more %} 最近物联网(IoT)带来的范式转变使嵌入式系统成为安全分析师和恶意对手的目标。物联网设备缺乏标准化的硬件、多样化的软件和不透明的功能，由于其固件和设计的硬件之间的紧密耦合，给安全分析师带来了独特的挑战。为了利用现代程序分析技术，如模糊或符号执行，以任何类型的规模或深度，分析人员必须有能力在模拟(或虚拟化)环境中执行固件代码。然而，这些仿真环境很少可用，并且通过手动反向工程创建起来很麻烦，这极大地限制了二进制固件的分析。在本文中，我们探讨了固件重新托管的问题，即固件从其原始硬件环境迁移到虚拟化环境的过程。我们展示了一种能够以自动化方式创建虚拟交互环境的方法，这是实现大规模固件分析的必要条件。我们提出了旨在实现这一目标的第一个概念验证系统，称为PRETENDER，它使用对原始硬件和固件之间交互的观察来自动创建外设的模型，并允许在完全模拟的环境中执行固件。与以前的方法不同，这些模型是交互式的、有状态的和可转移的，这意味着它们被设计为允许程序接收和处理新的输入，这是许多分析的需求。我们在多个硬件平台和固件示例上演示了我们的方法，并展示了模型足够灵活，以允许虚拟化代码执行、探索新的代码路径和识别安全漏洞。 {% endspoiler %}\nStatic Analysis Karonte: Detecting Insecure Multi-binary Interactions in Embedded Firmware (2020) {% spoiler more %} 低功耗、单一用途的嵌入式设备（例如路由器和物联网设备）已经无处不在。虽然它们自动化并简化了用户生活的许多方面，但最近的大规模攻击表明，它们的数量对互联网基础设施构成了严重威胁。不幸的是，这些系统上的软件依赖于硬件，并且通常在具有非标准配置的独特、最小环境中执行，这使得安全分析特别具有挑战性。许多现有设备通过使用多个二进制文件来实现其功能。这种多二进制服务实现使当前的静态和动态分析技术无效或低效，因为它们无法识别和充分建模各种可执行文件之间的通信。在本文中，我们介绍了 KARONTE，这是一种静态分析方法，能够通过建模和跟踪多二进制交互来分析嵌入式设备固件。我们的方法在二进制文件之间传播污染信息以检测不安全的交互并识别漏洞。我们首先在来自不同供应商的 53 个固件样本上评估了 KARONTE，表明我们的原型工具可以成功地跟踪和约束多二进制交互。这导致发现了 46 个零日漏洞。然后，我们对 899 个不同的样本进行了大规模实验，表明 KARONTE 可以很好地适应不同大小和复杂性的固件样本。 {% endspoiler %}\nFirmalice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware (2015) {% spoiler more %} 嵌入式设备已经无处不在，它们被用于一系列隐私敏感和安全关键的应用程序中。这些设备中的大多数都运行专有软件，几乎没有关于软件内部工作的文档。在某些情况下，硬件和保护机制的成本可能会使访问设备本身变得不可行。如果必须避免与软件错误和漏洞相关的风险，则分析此类环境中存在的软件具有挑战性，但也是必要的。事实上，最近的研究表明，市场上的许多嵌入式设备都存在后门。在本文中，我们介绍了 Firmalice，这是一个二进制分析框架，用于支持分析在嵌入式设备上运行的固件。 Firmalice 建立在符号执行引擎和程序切片等技术之上，以提高其可扩展性。此外，Firmalice 利用一种新颖的身份验证绕过漏洞模型，基于攻击者确定执行特权操作所需输入的能力。我们在三个市售设备的固件上评估了 Firmalice，并且能够在其中两个设备中检测到身份验证绕过后门。此外，Firmalice 能够确定第三个固件样本中的后门不能被攻击者在不知道一组非特权凭证的情况下利用。 {% endspoiler %}\nGeneral Symoblic Execution SymQEMU:Compilation-based symbolic execution for binaries (2021) {% spoiler more %} 带你搞懂符号执行的前世今生与最近技术 符号执行是一种强大的软件分析和错误检测技术。基于编译的符号执行是最近提出的一种风格，已被证明可以在源代码可用时显着提高符号执行的性能。我们展示了一种新技术，可以实现基于编译的二进制符号执行（即，无需源代码）。我们的系统 SymQEMU 构建在 QEMU 之上，在将目标程序转换为主机架构之前修改目标程序的中间表示。这使 SymQEMU 能够将符号执行功能编译到二进制文件中，并在保持架构独立性的同时获得相关的性能优势。 我们展示了我们的方法和实现，并证明它在统计上优于最先进的二进制符号执行器 S2E 和 QSYM；在某些基准测试中，它甚至比基于源代码的 SymCC 获得了更好的性能。此外，我们的工具在经过良好测试的 libarchive 库中发现了一个以前未知的漏洞，证明了它在测试真实世界软件中的实用性。 {% endspoiler %}\nSystematic Comparison of Symbolic Execution Systems: Intermediate Representation and its Generation (2019) {% spoiler more %} 符号执行已成为一种流行的软件测试和漏洞检测技术。大多数实现将正在分析的程序转换为某种中间表示 (IR)，然后将其用作符号执行的基础。有大量可用的 IR，甚至还有更多方法可以将目标程序转换为相应的 IR。 在开发符号执行引擎时，需要选择一个 IR，但不清楚 IR 生成过程对生成的系统有何影响。从源代码生成 IR 与提升机器代码的符号执行各自有什么好处？区别甚至重要吗？不使用 IR，直接执行机器代码有什么影响？我们认为几乎没有科学证据支持这些问题的答案。因此，我们首先开发了一种系统比较符号执行的不同方法的方法；然后，我们用它来评估选择 IR 和 IR 生成的影响。我们将我们的比较框架提供给社区以供未来研究。 {% endspoiler %}\nA Survey of Symbolic Execution Techniques (2016) {% spoiler more %} 许多安全和软件测试应用程序需要检查程序的某些属性是否适用于任何可能的使用场景。例如，用于识别软件漏洞的工具可能需要排除任何后门的存在以绕过程序的身份验证。一种方法是使用不同的、可能是随机的输入来测试程序。由于后门可能只针对非常特定的程序工作负载而受到攻击，因此对可能输入空间的自动探索至关重要。符号执行通过系统地同时探索许多可能的执行路径而不必需要具体的输入，为该问题提供了一个优雅的解决方案。该技术不是采用完全指定的输入值，而是将它们抽象地表示为符号，诉诸约束求解器来构造可能导致属性违规的实际实例。符号执行在过去 4 年中开发的数十种工具中得到了孵化，在许多著名的软件可靠性应用程序中取得了重大的实际突破。本次调查的目的是概述该领域开发的主要想法、挑战和解决方案，并将其提炼给广大受众。 {% endspoiler %}\n(State of) The Art of War: Offensive Techniques in Binary Analysis (2016) {% spoiler more %} 寻找和利用二进制代码中的漏洞是一项具有挑战性的任务。缺乏有关数据结构和控制结构的高层次、语义丰富的信息使得对程序属性的分析难以扩展。然而，二元分析的重要性正在上升。在许多情况下，二进制分析是唯一可能证明(或否定)实际执行的代码属性的方法。 在本文中，我们提出了一个二元分析框架，它实现了过去提出的许多分析技术。我们提出了这些技术的系统化实现，这允许其他研究人员组合他们，并开发新的方法。此外，在统一的框架中实现这些技术允许对这些方法进行直接比较，并确定它们的优点和缺点。本文所包含的评估是使用DARPA创建的用于评估二进制漏洞分析技术有效性的最新数据集进行的。 我们的框架是开源的，安全社区可以使用。 {% endspoiler %}\nVehicle Cyber–Physical Security of Powertrain Systems in Modern Electric Vehicles: Vulnerabilities, Challenges, and Future Visions (2021) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-7\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %} 由于电力电子系统在物联网(IoT)应用领域(包括联网电动汽车)的日益普及，它们越来越容易受到网络物理威胁。为了响应这一新兴需求，IEEE电力电子学会(peles)最近发起了一项网络物理安全倡议。随着V2X (vehicle-to-everything)和电子控制单元数量的增加，联网电动汽车面临着更大的网络物理安全挑战。然而，现有的研究主要集中在内燃机汽车的网络安全方面，并没有具体解决电动汽车的网络物理安全问题。本文从固件安全、车辆充电安全、动力系统控制安全等方面探讨了联网电动汽车网络物理安全面临的挑战和未来前景。在各种网络攻击下，电动汽车的漏洞被调查，从能源效率驱动的攻击到安全驱动的攻击。仿真结果包括硬件在环(HIL)结果，进一步分析了网络攻击对转换器(设备)和车辆(系统)级别的影响。更重要的是，下一代电力电子系统的架构被提出，以解决电动汽车的网络物理安全挑战。最后，详细讨论了潜在的研究机会，包括针对固件安全性的检测和迁移、基于模型和数据驱动的检测和缓解。据我们所知，这是首次对现代电动汽车动力系统的网络物理安全进行全面研究。 {% endspoiler %}\nA Brief Survey on Autonomous Vehicle Possible Attacks,Exploits and Vulnerabilities (2021) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-8\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %} 先进的驾驶辅助系统正在快速发展，各大企业都开始投资开发自动驾驶汽车。但安全性和可靠性仍然是不确定和有争议的。想象一下，一辆车被攻击者破坏了，然后他们能做什么。攻击者可以控制刹车，加速，甚至转向，这可以导致灾难性的后果。本文简要概述了自动驾驶汽车软件和硬件可能受到的大多数攻击及其潜在影响。 {% endspoiler %}\nResearch on Detection and Evaluation Technology of Cybersecurity in Intelligent and Connected Vehicle (2019) {% spoiler more %} {% post_link \u0026lsquo;paper-vfsf-6\u0026rsquo; \u0026lsquo;Note\u0026rsquo; %} 随着汽车智能化和网络互联的不断发展，智能联网汽车(ICV)的网络安全问题日益突出。但目前汽车行业缺乏软件测试工具，缺乏网络安全检测与评估是亟待解决的严重问题。本文针对这一问题，开展了ICV检测评估平台的研究，并对ICV网络安全检测技术进行了探索。此外，我们建立汽车网络安全漏洞数据库提供数据支撑，利用源代码分析、固件反向、渗透测试、仿真等检测技术，对汽车终端、数据通信、云平台、APP等进行网络安全评估。设计全检测和风险评估，构建ICV安全检测评估平台。 {% endspoiler %}\nOther Reference Recent Papers Related To Fuzzing ","permalink":"https://eveneko.com/posts/firmware-readpaper/","summary":"本页面收录和车辆固件在模拟环境下模糊测试相关的论文。(43篇) All Papers(Classification according to Subject) Survey/Review Detecting Vulnerability on IoT Device Firmware: A Survey (2022) {% spoiler more %} 物联网 (IoT) 设备占所有网络连接端点的 30%，引入了漏洞和新颖的攻击，使许多公司成为网络犯罪分子的主要目标。为了应对这种日益增加的威胁面，每个部署物联网设备的组织都需要考虑安全风险，以确","title":"Firmware Readpaper"},{"content":"工具箱 mkv转mp4 https://github.com/Yang-Xijie/mkv2mp4_fcp mCamRig 插件能够简单快速的将图层实现摄像机三维运动和翻转角度控制 commandpost 资料 插件下载 https://www.motionvfx.com FCPX插件及剪辑课程 https://pan.baidu.com/s/1mYmg6LcsKDjL_4gaFPX8HQ?pwd=r82m 提取码: r82m 高速下载地址 https://www.123pan.com/s/arPRVv-sE9D3 QA h264 和 h265 的区别\nH.265是新的编码协议，也即是H.264的升级版。H.265标准保留H.264原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置；\n","permalink":"https://eveneko.com/posts/fcpx-tutorial/","summary":"工具箱 mkv转mp4 https://github.com/Yang-Xijie/mkv2mp4_fcp mCamRig 插件能够简单快速的将图层实现摄像机三维运动和翻转角度控制 commandpost 资料 插件下载 https://www.motionvfx.com FCPX插件及剪辑课程 https://pan.baidu.com/s/1mYmg6LcsKDjL_4gaFPX8HQ?pwd=r82m 提取码: r82m 高速下载地址 https://www.123pan.com/s/arPRVv-sE9D3 QA h264 和 h265 的区别 H.265是新的编码协议，也即是H.264的升级版。H.265标准保留H.264原来的某些技术，同时对一些相关的技术加以改","title":"Fcpx 入门"},{"content":"前言 学习路线主要是根据Vue vben admin，一个免费开源的中后台模版来学习。\n内容 node 和 git -项目开发环境 Vite - 熟悉 vite 特性 Vue3 - 熟悉 Vue 基础语法 TypeScript - 熟悉TypeScript基本语法 Es6+ - 熟悉 es6 基本语法 Vue-Router-Next - 熟悉 vue-router 基本使用 Ant-Design-Vue - ui 基本使用 Mock.js - mockjs 基本语法 参考 手撕vben ","permalink":"https://eveneko.com/posts/vue-tutorial/","summary":"前言 学习路线主要是根据Vue vben admin，一个免费开源的中后台模版来学习。 内容 node 和 git -项目开发环境 Vite - 熟悉 vite 特性 Vue3 - 熟悉 Vue 基础语法 TypeScript - 熟悉TypeScript基本语法 Es6+ - 熟悉 es6 基本语法 Vue-Router-Next - 熟悉 vue-router 基本使用 Ant-Design-Vue - ui 基本使用 Mock.js - mockjs 基本语法 参考 手撕vben","title":"Vue 入门"},{"content":"女朋友送的礼物，当然要好好折腾折腾\n引言 树莓派到如今已经发布了4代，性能自然是越来越强了，每一代都分为A、B型，也有比较特殊的型号比如去掉大部分接口很小巧的树莓派Zero、去掉所有接口的树莓派计算型CM（Compute Module）、B型的增强型B+等。其中B型是最常用的，而A、B型区别也只在于尺寸和接口不同，SoC基本都是一致的。\n设备 MacBook Pro (14-inch, 2021) Raspberry Pi Model B (4GB) 硬件 主要接口 GPIO 引脚 散热器 风扇的接线是接载树莓派最外排是从右往左数第二和第三个引脚上，红色接第二根引脚（+5V），黑色接第三根引脚（GND）。\n搭建系统 树莓派开发板没有配置板载 FLASH，它支持 SD 卡启动（或者从U盘启动），所以我们需要下载相应镜像，并将其烧写在 SD 上制作系统盘。\n支持的系统如下： Raspbian、Arch Linux ARM、Debian Squeeze、Firefox OS、Gentoo Linux、Google Chrome OS、Raspberry Pi Fedora Remix、Slackware ARM、QtonPi、Slackware ARM、WebOS、RISC OS、FreeBSD、NetBSD、Android 4.0(Ice Cream Sandwich)\n下载镜像 https://www.raspberrypi.com/software/operating-systems/\n建议 NOOBS 安装。Mac用户直接可以跳过。\n镜像烧写 准备工作 TF卡（2GB以上） 读卡器 Raspberry Pi Imager（Mac烧录工具） Tips\n4b没有标准HDMI接口，只有micro HDMI接口 建议准备一根网线，直连在路由器上，这样方便获得树莓派ip地址 默认树莓派没有开启ssh，vnc服务，所以在无法连接显示屏的情况下，建议下载已经修改过设置的镜像 树莓派访问方式 外接 HDMI 或者 AV 显示器，USB 鼠标、键盘\n初次连接使用 使用 USB 转 TTL 串口模块通过串口访问树莓派\nSSH\nusername: pi password: raspberry VNC\n运营商普遍屏蔽了5900这个端口，注意转发\n树莓派配置 经过前面的步骤，树莓派已经可以正常工作了，但在正式开发使用之前，还需要做一些配置。\n树莓派第一次使用的时候需要进行一个简单的配置，在命令行模式下运行以下命令：\n1 sudo raspi-config System Options Wireless LAN 无线设置 Password 修改密码 Interface Options SSH 开启SSH VNC 开启VNC Localisation Options Lacale 建议英文 Timezone 初始为英国，这里改成 Shanghai/Hong Kong Overclock 超频选项，新手不建议调整 树莓派网络与更新配置 有线网络 自动获取 IP：树莓派默认有线网卡是使能的，只需将网线插入树莓派网卡，即可自动获得 IP(要求在局域网内)。 手动设定 IP：如果是电脑与树莓派直连，不能自动获得 IP，可以使用：ifconfig eth0 192.168.1.123 设定 ip(下次重启就没了)。 设置静态 IP：如果担心在同网络情况下 ip 或者不固定，可以讲电脑设置为静态 ip 打开文件 /etc/dhcpcd.conf 修改 # Example static IP configuration 下面的配置 无线网络 4b带有WiFi模块，所以可以直接跳过。\n更新软件源 Linux的软件不像Windows，基本都是需要在线安装的，但是树莓派由于各种原因其默认的软件源在国内速度并不是很理想，所以需要更新一下软件源。\n软件更新源\n1 sudo vi /etc/apt/sources.list 系统更新源\n1 sudo vi /etc/apt/sources.list.d/raspi.list 这里我们使用 清华源 ，根据自己机器操作系统的版本修改文件内容。\n查看系统版本\n1 lsb_release -a 1 2 3 4 5 No LSB modules are available. Distributor ID:\tRaspbian Description:\tRaspbian GNU/Linux 10 (buster) Release:\t10 Codename:\tbuster 挂载 使用fdisk命令查看设备硬盘情况\n1 sudo fdisk -l 使用 df 查看挂载情况\n1 df -h 手动挂载 在 /mnt 下新建一个目录作为挂载点\n1 sudo mkdir /mnt/udisk 挂载\n1 sudo mount -o uid=pi,gid=pi /dev/sda1 /mnt/udisk 卸载\n1 sudo umount /mnt/1GB_USB_flash Tips\nsda1 是取决于你的实际情况，a 表示第一个硬盘，1 表示第一个分区。 FAT 格式 U 盘 mount 本身就能支持，但如果你的 U 盘或移动硬盘使用的是 exFAT 格式，mount 会说不支持。 安装 exfat-fuse 软件之后 mount 就支持了。 sudo apt-get install exfat-fuse 开机挂载 在 /etc/fstab 中新增一行，每次开机都会挂载\n1 /dev/sda1 /mnt/udisk vfat rw,defaults 0 0 热插挂载 需要希望想电脑一样，插上自动识别挂载在某一目录下，拔下自动 umount，按以下操作，会自动在 /mnt/udisk 目录下挂载 U 盘。\n新建文件\n1 sudo vi /etc/udev/rules.d/10-usbstorage.rules 输入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 KERNEL!=\u0026#34;sd*\u0026#34;, GOTO=\u0026#34;media_by_label_auto_mount_end\u0026#34; SUBSYSTEM!=\u0026#34;block\u0026#34;,GOTO=\u0026#34;media_by_label_auto_mount_end\u0026#34; IMPORT{program}=\u0026#34;/sbin/blkid -o udev -p %N\u0026#34; ENV{ID_FS_TYPE}==\u0026#34;\u0026#34;, GOTO=\u0026#34;media_by_label_auto_mount_end\u0026#34; ENV{ID_FS_LABEL}!=\u0026#34;\u0026#34;, ENV{dir_name}=\u0026#34;%E{ID_FS_LABEL}\u0026#34; ENV{ID_FS_LABEL}==\u0026#34;\u0026#34;, ENV{dir_name}=\u0026#34;Untitled-%k\u0026#34; ACTION==\u0026#34;add\u0026#34;, ENV{mount_options}=\u0026#34;relatime,sync\u0026#34; ACTION==\u0026#34;add\u0026#34;, ENV{ID_FS_TYPE}==\u0026#34;vfat\u0026#34;, ENV{mount_options}=\u0026#34;iocharset=utf8,umaskk =000\u0026#34; ACTION==\u0026#34;add\u0026#34;, ENV{ID_FS_TYPE}==\u0026#34;ntfs\u0026#34;, ENV{mount_options}=\u0026#34;iocharset=utf8,umaskk =000\u0026#34; ACTION==\u0026#34;add\u0026#34;, RUN+=\u0026#34;/bin/mkdir -p /mnt/udisk/\u0026#34;, RUN+=\u0026#34;/bin/mount -o $env{mount__ options} /dev/%k /mnt/udisk/\u0026#34; ACTION==\u0026#34;remove\u0026#34;, ENV{dir_name}!=\u0026#34;\u0026#34;, RUN+=\u0026#34;/bin/umount -l /mnt/udisk/}\u0026#34;, RUN+=\u0026#34;// bin/rmdir /mnt/udisk/\u0026#34; LABEL=\u0026#34;media_by_label_auto_mount_end\u0026#34; 4b上不需要这个功能，默认挂在 /media/pi/\u0026lt;udisk_name\u0026gt;\n墨水屏 1 2 3 4 5 6 7 8 9 10 == Hardware connection == EPD =\u0026gt; Raspberry Pi * VCC -\u0026gt; 3.3 * GND -\u0026gt; GND * DIN -\u0026gt; MOSI * CLK -\u0026gt; SCLK * CS -\u0026gt; 24 (Physical, BCM: CE0, 8) * D/C -\u0026gt; 22 (Physical, BCM: 25) * RES -\u0026gt; 11 (Physical, BCM: 17) * BUSY -\u0026gt; 18 (Physical, BCM: 24) 软件 统计端口 application local port url smb 139,445 mysql 3306 calendar 5000 calendar.pi.eveneko.com:9000 vnc 5900 pi.eveneko.com:5901 pihole_web 8488 clash_web 8588 clash.pi.eveneko.com:9000 clash 7890,9090 nextcloud 8688 aria2 6800 ariaNg 8788 aria2.pi.eveneko.com:9000 frp dashboard 7500 pi.eveneko.com:7500 jupyter 8888 jupyter.pi.eveneko.com:9000 portainer 8988 portainer.pi.eveneko.com:9000 中文 安装中文字库\n1 sudo apt-get install ttf-wqy-zenhei 安装中文输入法\n1 sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin python3 默认使用python3\n1 2 sudo rm /usr/bin/python sudo ln -s /usr/bin/python3.7 /usr/bin/python 换源\n临时使用\n1 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 设为默认\n1 2 pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip3 install pip -U nginx 安装\n1 sudo apt-get install nginx 其他命令\n1 2 3 4 5 6 # 启动 nginx systemctl start nginx # 停止 systemctl stop nginx # 加载配置文件 systemctl reload nginx 启动\n1 systemctl enable nginx jupyterlab 安装\n1 pip3 install jupyter 配置\n1 python3 -m jupyter notebook --generate-config 修改以下内容\n1 2 3 4 5 6 7 8 c.NotebookApp.allow_origin = \u0026#39;*\u0026#39; c.NotebookApp.ip = \u0026#39;0.0.0.0\u0026#39; c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 c.NotebookApp.notebook_dir = \u0026#39;\u0026lt;/home/pi\u0026gt;\u0026#39; c.NotebookApp.allow_root = True c.NotebookApp.allow_remote_access = True c.NotebookApp.token = \u0026#39;\u0026#39; 开机自启动\n在 /etc/init.d 下新建文件 jupyter.init\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash ### BEGIN INIT INFO # Provides: jupyter # Required-Start: $local_fs $remote_fs $network $syslog # Required-Stop: $local_fs $remote_fs $network $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: jupyter service # Description: jupyter service daemon ### END INIT INFO case \u0026#34;$1\u0026#34; in start) echo \u0026#34;starting jupyterlab\u0026#34; su pi -c \u0026#34;nohub python3 -m jupyterlab \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; ;; stop) echo \u0026#34;stopping jupyterlab\u0026#34; kill $(ps aux|grep -m 1 \u0026#39;python3 -m jupyterlab\u0026#39;|awk \u0026#39;{ print $2}\u0026#39;) ;; *) echo \u0026#34;Usage: service jupyterlab start|stop\u0026#34; exit 1 ;; esac exit 0 添加权限\n1 sudo chmod +x /etc/init.d/jupyter.init 设置开机启动\n1 sudo update-rc.d jupyter.init defaults 重启\nrcconf 查看启动项\n开机启动目前用supervisor实现，还可以守护进程。\nfrp内网穿透 frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。\n在 frp releases 下载对应版本的frp\n下载后，对应修改 frps.ini\n服务端\n1 2 3 4 5 6 7 8 9 [common] bbind_port = 7000 privilege_token = eveneko max_pool_count = 5 dashboard_port = 7500 dashboard_user = admin dashboard_pwd = admin vhost_http_port = 9000 #subdomain_host = pi.eveneko.com 后台启动\n1 nohup ./frps -c frps.ini\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 在 /etc/init.d 下新建文件 frps.init\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash ### BEGIN INIT INFO # Provides: frp # Required-Start: $local_fs $remote_fs $network $syslog # Required-Stop: $local_fs $remote_fs $network $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: frps service # Description: frps service daemon ### END INIT INFO case \u0026#34;$1\u0026#34; in start) echo \u0026#34;starting frps\u0026#34; nohup /home/ubuntu/Workspace/frp/frps -c /home/ubuntu/Workspace/frp/frps.ini\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; ;; stop) echo \u0026#34;stopping frps\u0026#34; kill $(ps aux|grep -m 1 \u0026#39;/home/ubuntu/Workspace/frp/frps -c /home/ubuntu/Workspace/frp/frps.ini\u0026#39;|awk \u0026#39;{ print $2}\u0026#39;) ;; *) echo \u0026#34;Usage: service frps start|stop\u0026#34; exit 1 ;; esac exit 0 开机启动目前用supervisor实现，还可以守护进程。\n客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 [common] server_addr = pi.eveneko.com server_port = 7000 privilege_token = eveneko [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 2222 [pi-vnc] type = tcp local_ip = 127.0.0.1 local_port = 5900 remote_port = 5901 [pi-jupyter] type = http local_port = 8888 custom_domains = jupyter.pi.eveneko.com #subdomain = jupyter [pi-ariaNg] type = http local_port = 8788 custom_domains = aria2.pi.eveneko.com [pi-aria2] type = tcp local_ip = 127.0.0.1 local_port = 6800 remote_port = 6800 [pi-portainer] type = http local_port = 8988 custom_domains = portainer.pi.eveneko.com [pi-clash] type = http local_port = 8588 custom_domains = clash.pi.eveneko.com [pi-calendar] type = http local_port = 5000 custom_domains = calendar.pi.eveneko.com 后台启动\n1 nohup ./frpc -c frpc.ini\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 在 /etc/init.d 下新建文件 frpc.init\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash ### BEGIN INIT INFO # Provides: frp # Required-Start: $local_fs $remote_fs $network $syslog # Required-Stop: $local_fs $remote_fs $network $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: frpc service # Description: frpc service daemon ### END INIT INFO case \u0026#34;$1\u0026#34; in start) echo \u0026#34;starting frpc\u0026#34; nohup /home/pi/Workspace/frp/frpc -c /home/pi/Workspace/frp/frpc.ini\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; ;; stop) echo \u0026#34;stopping frpc\u0026#34; kill $(ps aux|grep -m 1 \u0026#39;/home/pi/Workspace/frp/frpc -c /home/pi/Workspace/frp/frpc.ini\u0026#39;|awk \u0026#39;{ print $2}\u0026#39;) ;; *) echo \u0026#34;Usage: service frpc start|stop\u0026#34; exit 1 ;; esac exit 0 开机启动目前用supervisor实现，还可以守护进程。\nsupervisor 帮助我们守护进程，自动恢复服务\n安装\n1 sudo apt-get install supervisor 配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [program:frpc] directory = /home/pi/Workspace/frp/ ; command = /home/pi/Workspace/frp/frpc -c /home/pi/Workspace/frp/frpc.ini ; root = pi ; stopsignal = INT ; autostart = true ; startsecs = 5 ; autorestart = true ; startretries = 10 ; stopasgroup = true ; killasgroup = true ; redirect_stderr = true ; stdout_logfile_maxbytes = 20MB ; stdout_logfile_backups = 20 ; stdout_logfile = /var/log/frpc.log ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [program:jupyterlab] directory = /home/pi/ ; command = python3 -m jupyterlab ; user = pi ; stopsignal = INT ; autostart = true ; startsecs = 10 ; autorestart = true ; startretries = 10 ; stopasgroup = true ; killasgroup = true ; redirect_stderr = true ; stdout_logfile_maxbytes = 20MB ; stdout_logfile_backups = 20 ; stdout_logfile = /var/log/jupyterlab.log ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [program:ncovbot] directory = /home/pi/Workspace/BUPT-NCOV-AUTO-REPORT-BOT/ ; command = /home/pi/Workspace/BUPT-NCOV-AUTO-REPORT-BOT/venv/bin/python3 ./main.py ; environment=http_proxy=\u0026#34;http://localhost:7890\u0026#34;,https_proxy=\u0026#34;http://localhost:7890\u0026#34; user = pi ; stopsignal = INT ; autostart = true ; startsecs = 5 ; autorestart = true ; startretries = 10 ; stopasgroup = true ; killasgroup = true ; redirect_stderr = true ; stdout_logfile_maxbytes = 20MB ; stdout_logfile_backups = 20 ; stdout_logfile = /var/log/ncovbot.log ; 注意 supervisor 的环境变量需要\n重新加载配置\n1 sudo supervisorctl reload 查看状态\n1 sudo supervisorctl status 注意user是root到时候，可能会出现一下环境问题\ndocker docker\n1 sudo curl -sSL https://get.docker.com | sh 换源\n1 sudo vim /etc/docker/daemon.json 1 2 3 { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.docker-cn.com\u0026#34;] } docker-compose\nDocker Compose 的安装方式有很多种，但由于 ARM 架构的限制，树莓派上的 Docker Compose 建议使用 pip 安装。\n1 sudo pip3 install -U docker-compose ui\n1 2 3 sudo docker volume create portainer_data sudo docker run -d -p 8988:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/ 默认用户admin\nAria2 Aria2 是一款自由、跨平台命令行界面的下载管理器，和 wget 这类下载器不同的是，Aria2 不仅支持 BitTorrent，还能够从各种来源多路检索所请求的文件。包括 HTTP，HTTPS，FTP 和 BitTorrent 协议。\n而且 Raspbain 系统默认已经安装了 Aria2，运行 apt-cache show aria2 即可查看安装信息。\n1 sudo docker run -d --name aria2-ui-pi -p 8788:80 -p 6800:6800 -v /data:/data --restart=always huangzulin/aria2-ui-pi 默认用户/密码 admin/admin\nmysql 为Nextcloud准备\n1 2 3 4 5 6 7 8 docker pull mysql docker run -d -p 3306:3306 -v /mnt/sde/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw --name mysql mysql # linux/arm/v7 不支持mysql，需要安装 docker pull hypriot/rpi-mysql docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d -p 12345:3306 hypriot/rpi-mysql Nextcloud Nextcloud是一款开源免费的私有云存储网盘项目，可以让你快速便捷地搭建一套属于自己或团队的云同步网盘，从而实现跨平台跨设备文件同步、共享、版本控制、团队协作等功能。它的客户端覆盖了Windows、Mac、Android、iOS、Linux 等各种平台，也提供了网页端以及 WebDAV接口，所以你几乎可以在各种设备上方便地访问你的云盘。\n1 2 3 sudo docker pull nextcloud docker run -d --restart=always -p 8688:80 -v /mnt/sde/nextcloud:/var/www/html -v /mnt/sde:/var/www/data -link mysql:mysql --name nextcloud nextcloud \u0026ndash;link 链接数据库容器，链接使用mysql容器镜像mysql（容器名称）, 不使用则为sqlite数据库 -v 挂载目录，将容器/var/www/html挂载到主机/mnt/sde/nextcloud下面，html为服务路径，稍后会修改/mnt/sde/nextcloud/config/config.php的data，修改data的目录\ndocker-compose.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 version: \u0026#39;2\u0026#39; services: mysql: image: ibex/debian-mysql-server-5.7 restart: always volumes: - db:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_PASSWORD=\u0026lt;password\u0026gt; - MYSQL_DATABASE=nextcloud - MYSQL_USER=nextcloud container_name: mysql nextcloud: image: arm32v7/nextcloud ports: - 8688:80 links: - mysql volumes: - nextcloud:/var/www/html restart: always container_name: nextcloud volumes: db: nextcloud: 等一块硬盘盒\nsmb 1 docker run -d -p 139:139 -p 445:445 --name samba -v /mnt/sde:/mount --restart=always dperson/samba -u \u0026#34;root;root\u0026#34; -s \u0026#34;root;/mount/;yes;no;yes;all;all;all\u0026#34; -w \u0026#34;WORKGROUP\u0026#34; -g \u0026#34;force user=root\u0026#34; -g \u0026#34;guest account=root\u0026#34; clash 科学上网，dddd\ndocker-compose.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 version: \u0026#39;3\u0026#39; services: clash: # ghcr.io/dreamacro/clash # ghcr.io/dreamacro/clash-premium # dreamacro/clash # dreamacro/clash-premium image: dreamacro/clash container_name: clash volumes: - ./config.yaml:/root/.config/clash/config.yaml # - ./ui:/ui # dashboard volume ports: - \u0026#34;7890:7890\u0026#34; - \u0026#34;7891:7891\u0026#34; - \u0026#34;9090:9090\u0026#34; # - \u0026#34;8080:8080\u0026#34; # external controller (Restful API) # # TUN # cap_add: # - NET_ADMIN # devices: # - /dev/net/tun restart: unless-stopped #network_mode: \u0026#34;bridge\u0026#34; # or \u0026#34;host\u0026#34; on Linux clash_web: image: haishanh/yacd restart: always depends_on: - clash ports: - 8588:80 container_name: clash_web 创建 config.yaml后，执行\n1 sudo docker-compose up -d 查看log\n1 sudo docker-compose logs 停止clash\n1 docker-compose stop 测试\n1 curl -x 127.0.0.1:7890 http://www.google.com 设置代理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Define `setproxy` command to enable proxy configuration setproxy() { export http_proxy=\u0026#34;http://localhost:7890\u0026#34; export https_proxy=\u0026#34;http://localhost:7890\u0026#34; } # Define `unsetproxy` command to disable proxy configuration unsetproxy() { unset http_proxy unset https_proxy } # By default, enable proxy configuration for terminal login setproxy pihole Pi-hole 是一款开源且免费的 DNS 沉洞服务器（DNS sinkhole）\ndocker-compose.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 version: \u0026#34;3\u0026#34; # More info at https://github.com/pi-hole/docker-pi-hole/ and https://docs.pi-hole.net/ services: pihole: container_name: pihole image: pihole/pihole:latest ports: - \u0026#34;53:53/tcp\u0026#34; - \u0026#34;53:53/udp\u0026#34; #- \u0026#34;67:67/udp\u0026#34; # Only required if you are using Pi-hole as your DHCP server - \u0026#34;8488:80/tcp\u0026#34; environment: TZ: \u0026#39;America/Chicago\u0026#39; # WEBPASSWORD: \u0026#39;set a secure password here or it will be random\u0026#39; # Volumes store your data between container upgrades volumes: - \u0026#39;./etc-pihole:/etc/pihole\u0026#39; - \u0026#39;./etc-dnsmasq.d:/etc/dnsmasq.d\u0026#39; # https://github.com/pi-hole/docker-pi-hole#note-on-capabilities cap_add: - NET_ADMIN # Recommended but not required (DHCP needs NET_ADMIN) restart: unless-stopped web\nhttp://ip.hole/\nhttp://\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt;/admin\nad host\nhttps://github.com/otobtc/ADhosts https://github.com/privacy-protection-tools/anti-AD 国内广告屏蔽不够全面 设备有时候不自动更换dns\n","permalink":"https://eveneko.com/posts/raspberry-pi-tutorial/","summary":"女朋友送的礼物，当然要好好折腾折腾 引言 树莓派到如今已经发布了4代，性能自然是越来越强了，每一代都分为A、B型，也有比较特殊的型号比如去掉大部分接口很小巧的树莓派Zero、去掉所有接口的树莓派计算型CM（Compute Module）、B型的增强型B+等。其中B型是最常用的，而A、B","title":"Raspberry Pi 指北"},{"content":"安装依赖 for ubuntu\n1 sudo apt-get install build-essential curl libcap-dev git cmake libncurses5-dev python-minimal python-pip unzip libtcmalloc-minimal4 libgoogle-perftools-dev libsqlite3-dev doxygen for ubuntu \u0026gt;= 18.04\n1 sudo apt-get install python3 python3-pip gcc-multilib g++-multilib 查看ubuntu版本\n1 cat /etc/lsb-release 安装lit以启用测试，tabulate支持klee-stats和wllvm中的其他功能，以便更容易将程序编译到LLVM位码\n1 pip3 install lit tabulate wllvm 安装 llvm9 1 sudo apt-get install clang-9 llvm-9 llvm-9-dev llvm-9-tools 安装约束求解器 任选其一\nSTP(recommend) Z3 metaSTM STP 外部依赖\n1 sudo apt-get install cmake bison flex libboost-all-dev python perl zlib1g-dev minisat 安装STP\n1 2 3 4 5 6 7 8 git clone https://github.com/stp/stp.git cd stp git checkout tags/2.3.3 c cd build cmake .. make -j sudo make install 在对更大的基准运行带有STP的KLEE之前，必须将堆栈的大小设置为非常大的值\n可以写到 .bashrc 持久化\n1 ulimit -s unlimited 获取KLEE 1 git clone https://github.com/klee/klee.git 配置KLEE 1 2 mkdir build cd build 配置选项\n1 2 3 4 5 6 7 8 9 10 11 cmake \\ -DENABLE_SOLVER_STP=ON \\ -DENABLE_POSIX_RUNTIME=ON \\ -DENABLE_KLEE_UCLIBC=ON \\ -DKLEE_UCLIBC_PATH=\u0026lt;KLEE_UCLIBC_SOURCE_DIR\u0026gt; \\ -DENABLE_UNIT_TESTS=ON \\ -DGTEST_SRC_DIR=\u0026lt;GTEST_SOURCE_DIR\u0026gt; \\ -DLLVM_CONFIG_BINARY=\u0026lt;PATH_TO_llvm-config-9\u0026gt; \\ -DLLVMCC=\u0026lt;PATH_TO_clang-9\u0026gt; \\ -DLLVMCXX=\u0026lt;PATH_TO_clang++-9\u0026gt; \\ \u0026lt;KLEE_SRC_DIRECTORY\u0026gt; 1 2 3 4 5 6 7 8 cmake \\ -DENABLE_SOLVER_STP=ON \\ -DENABLE_POSIX_RUNTIME=ON \\ -DENABLE_KLEE_UCLIBC=ON \\ -DKLEE_UCLIBC_PATH=/home/eveneko/Workspace/klee-uclibc \\ -DENABLE_UNIT_TESTS=OFF \\ -DENABLE_SYSTEM_TESTS=OFF \\ /home/eveneko/Workspace/klee 默认选项，这些选项不包括对uClibC和POSIX运行时的支持\n1 cmake .. Build KLEE 1 make -j Example get_sign 1 2 3 # examples/get_sign clang -I ../../include -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone get_sign.c clang -emit-llvm 将其编译为LLVM位码 -I 参数是为了让编译器可以找到klee/klee.h -g 构建以向位码文件添加调试信息非常有用，我们使用位码文件生成源线级统计信息。 -O0 -Xclang -disable-O0-optnone 传递给KLEE的位码不应该优化，因为我们手工为KLEE挑选了正确的优化。在较新的LLVM版本（\u0026gt;5.0）中，为KLEE编译时不应使用-O0零标志，因为它阻止KLEE进行自己的优化。 运行KLEE\n1 klee get_sign.bc KLEE生成的测试用例\n1 ktest-tool klee-last/test000001.ktest regexp 1 clang -I ../../include -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone Regexp.c -c 是因为我们希望将代码编译到对象文件（而不是本机可执行文件） llvm-nm来验证此步骤是否有效\n1 llvm-nm Regexp.bc 通常，在运行此程序之前，我们需要链接它才能创建本机可执行文件。然而，KLEE直接在LLVM位码文件上运行。\n由于此程序只有一个文件，因此无需链接。\n对于具有多个输入的“真实”程序，可以使用llvm链接工具代替常规链接步骤，将多个LLVM位码文件合并到一个模块中，该模块可以由KLEE执行。\n使用KLEE执行代码\n1 klee --only-output-states-covering-new Regexp.bc --only-output-states-covering-new 将测试生成限制在实际覆盖新代码的状态。 --emit-all-errors 为所有路径生成测试用例。 默认情况下，KLEE将运行到用户按下Control-C 停止。\n-max-time=\u0026lt;time span\u0026gt;：在给定的时间后停止执行，例如10min或1h5s。 -max-forks=N:停止在N符号分支之后分叉，并运行剩余的终止路径。 -max-memory=N:尝试将内存消耗限制在N兆字节。 Coreutils 使用gcov构建coreutils\n1 2 3 4 5 6 7 coreutils-6.11$ mkdir obj-gcov coreutils-6.11$ cd obj-gcov obj-gcov$ ../configure --disable-nls CFLAGS=\u0026#34;-g -fprofile-arcs -ftest-coverage\u0026#34; ... verify that configure worked ... obj-gcov$ make obj-gcov$ make -C src arch hostname ... verify that make worked ... --disable-nls 因为这在C库中添加了许多我们不感兴趣的额外初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 obj-gcov$ cd src src$ ls -l ls echo cat -rwxrwxr-x 1 klee klee 150632 Nov 21 21:58 cat -rwxrwxr-x 1 klee klee 135984 Nov 21 21:58 echo -rwxrwxr-x 1 klee klee 390552 Nov 21 21:58 ls src$ ./cat --version cat (GNU coreutils) 6.11 Copyright (C) 2008 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Torbjorn Granlund and Richard M. Stallman. 在gcov支持下构建\n我们可以使用gcov工具本身生成人类可读的覆盖信息形式\n1 2 3 4 5 6 7 8 9 10 11 12 13 src$ rm -f *.gcda # Get rid of any stale gcov files src$ ./echo** src$ ls -l echo.gcda -rw-rw-r-- 1 klee klee 896 Nov 21 22:00 echo.gcda src$ gcov echo File \u0026#39;../../src/echo.c\u0026#39; Lines executed:24.27% of 103 Creating \u0026#39;echo.c.gcov\u0026#39; File \u0026#39;../../src/system.h\u0026#39; Lines executed:0.00% of 3 Creating \u0026#39;system.h.gcov\u0026#39; 安装WLLVM\n1 pip install --upgrade wllvm 要成功执行WLLVM，必须将环境变量LLVM_COMPILER设置为底层LLVM编译器（dragonegg或clang）\n1 export LLVM_COMPILER=clang 使用LLVM构建Coreutils\n1 2 3 4 5 6 7 coreutils-6.11$ mkdir obj-llvm coreutils-6.11$ cd obj-llvm obj-llvm$ CC=wllvm ../configure --disable-nls CFLAGS=\u0026#34;-g -O1 -Xclang -disable-llvm-passes -D__NO_STRING_INLINES -D_FORTIFY_SOURCE=0 -U__OPTIMIZE__\u0026#34; ... verify that configure worked ... obj-llvm$ make obj-llvm$ make -C src arch hostname ... verify that make worked ... coreutils 可执行文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 obj-llvm$ cd src src$ ls -l ls echo cat -rwxrwxr-x 1 klee klee 105448 Nov 21 12:03 cat -rwxrwxr-x 1 klee klee 95424 Nov 21 12:03 echo -rwxrwxr-x 1 klee klee 289624 Nov 21 12:03 ls src$ ./cat --version cat (GNU coreutils) 6.11 Copyright (C) 2008 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Torbjorn Granlund and Richard M. Stallman. 我们获得的不是LLVM位码文件，而是可执行文件。\n要获取所有Coreutils的LLVM位码版本，我们可以在所有可执行文件上调用extract-bc：\n1 2 3 src$ find . -executable -type f | xargs -I \u0026#39;{}\u0026#39; extract-bc \u0026#39;{}\u0026#39; src$ ls -l ls.bc -rw-rw-r-- 1 klee klee 543052ls Nov 21 12:03 ls.bc 使用KLEE作为解释器\n1 klee --libc=uclibc --posix-runtime ./cat.bc --version 向应用程序介绍符号数据\n1 klee --libc=uclibc --posix-runtime ./echo.bc --sym-arg 3 获得KLEE内部统计数据的简短摘要\n1 klee-stats klee-last 运行LLVM优化传递\n1 klee --optimize --libc=uclibc --posix-runtime ./echo.bc --sym-arg 3 重播KLEE生成的测试用例\n1 klee-replay ./echo ../../obj-llvm/src/klee-last/test000001.ktest Reference http://klee.github.io/build-llvm9/ ","permalink":"https://eveneko.com/posts/klee-tutorial/","summary":"安装依赖 for ubuntu 1 sudo apt-get install build-essential curl libcap-dev git cmake libncurses5-dev python-minimal python-pip unzip libtcmalloc-minimal4 libgoogle-perftools-dev libsqlite3-dev doxygen for ubuntu \u0026gt;= 18.04 1 sudo apt-get install python3 python3-pip gcc-multilib g++-multilib 查看ubuntu版本 1 cat /etc/lsb-release 安装lit以启用测试，tabulate支持klee-stats和wllvm中的其他功能，以便更容易将程序编译到LLVM位码 1 pip3 install lit tabulate wllvm 安装 llvm9 1 sudo apt-get install clang-9 llvm-9 llvm-9-dev llvm-9-tools 安装约束求解器 任选其一 STP(recommend) Z3 metaSTM","title":"Klee 入门"},{"content":"设备 你需要一台可以装梅林系统的路由，最简单的就去购买华硕的路由器，当然那种和华硕配件一样的其他路由器也可以配置。\n我的路由器是 RT-AX56U，其实不是很推荐，因为没有usb接口且 jffs 分区过小(15M)，很多功能都无法完美使用。当然，还是有优点的，WiFi6+ASUS+相对便宜的价格。\n刷机 可以去官网下载官改固件，或者社区分析的梅林固件，和原版相比多了一个 ks软件中心 ，可以在线安装软件或者离线安装下载包。\n新站地址：https://www.koolcenter.com/ 固件下载：https://fw.koolcenter.com\nClash 安装梯子可能是最重要的事情，下面是傻瓜安装步骤：\n更新 ks软件中心 准备对于版本的 clash 准备 config.yaml , Country.mmdb 安装 可能遇到的问题写在FAQ里面。\n如果自己有能力，可以自己导入内核，设置 iptable ，设置透明代理 ，设置开机自启\u0026hellip;(如果你闲的无聊，想学习一遍计网和操作系统)。\nFAQ 检测到离线安装包含非法关键词\n```bash sed -i 's/\\tdetect_package/\\t# detect_package/g' /koolshare/scripts/ks_tar_install.sh ``` 格式化jffs分区\n先尝试 ```bash kill -9 $(pidof skipd) rm -rf /jffs/.asusrouter /jffs/.koolshare /jffs/.cert /jffs/.sys /jffs/.wtfast /jffs/* reboot ``` 如果不行，则用df -h命令查看查看具体挂载的分区名称，以jffs分区对应的挂载点是/dev/mtdblock9为例，对应的分区就是/dev/mtd9，用以下命令格式化分区： ```bash flash_erase -j /dev/mtd9 0 0 ``` 格式化完成后，输入以下命令初始化软件中心： ```bash jffsinit.sh cd /koolshare/perp \u0026amp;\u0026amp; sh perp.sh start service restart_skipd ``` 重启 ```bash reboot ``` clash RESTful API\n`config.yaml` 开启 `external-controller: 0.0.0.0:9090` 浏览器访问 http://clash.razord.top/#/proxies 透明代理\n要实现透明代理，按照官方文档必须启用DNS ```yaml dns: enable: true listen: 0.0.0.0:55 # 53被DNSmasq占用了，iptables配置会将53转到55 enhanced-mode: redir-host # 或 fake-ip nameserver: - 1.2.4.8 - 114.114.114.114 - 223.5.5.5 - tls://13800000000.rubyfish.cn:853 fallback: # 与 nameserver 内的服务器列表同时发起请求，当规则符合 GEOIP 在 CN 以外时，fallback 列表内的域名服务器生效。 - tls://13800000000.rubyfish.cn:853 - tls://1.0.0.1:853 - tls://dns.google:853 ``` 成功启动后接下来就是编写最为关键的 `iptables` 规则 clash-iptables\n```bash # ssh 的22端口 iptables -t nat -A PREROUTING -p tcp --dport 22 -j ACCEPT # 创建链 iptables -t nat -N Clash # 保留地址、私有地址、回环地址 不走代理 iptables -t nat -A Clash -d 0.0.0.0/8 -j RETURN iptables -t nat -A Clash -d 10.0.0.0/8 -j RETURN iptables -t nat -A Clash -d 127.0.0.0/8 -j RETURN iptables -t nat -A Clash -d 169.254.0.0/16 -j RETURN iptables -t nat -A Clash -d 172.16.0.0/12 -j RETURN iptables -t nat -A Clash -d 192.168.0.0/16 -j RETURN iptables -t nat -A Clash -d 224.0.0.0/4 -j RETURN iptables -t nat -A Clash -d 240.0.0.0/4 -j RETURN # 7892 是clash的redir端口 iptables -t nat -A Clash -p tcp -j REDIRECT --to-ports 7892 iptables -t nat -A PREROUTING -p tcp -j Clash # 53端口到55 iptables -t nat -A PREROUTING -p udp -m udp --dport 53 -j DNAT --to-destination 192.168.50.1:55 ``` 安装时出现 can't fork\n稍等一下安装，可能processes都被用完了。 Reference Merline Clash wiki AC68U上配置Clash透明Proxy记录 ","permalink":"https://eveneko.com/posts/asus-router-tutorial/","summary":"设备 你需要一台可以装梅林系统的路由，最简单的就去购买华硕的路由器，当然那种和华硕配件一样的其他路由器也可以配置。 我的路由器是 RT-AX56U，其实不是很推荐，因为没有usb接口且 jffs 分区过小(15M)，很多功能都无法完美使用。当然，还是有优点的，WiFi6+ASUS+相对便宜的价格","title":"Asus Router 指北"},{"content":"Go 模块 web 开发框架: gin orm 库: gorm 日志: logrus, zap Redis 客户端: go-redis Session 管理: go-session Go 设计模式: go-patterns Gin 官方文档: Gin 学习文章参考 Golang-100-Days Go语言高级编程 Go语言圣经 Go Modules 入门 跟煎鱼学Go golangbot Go 开发者成长路线图 参考项目 gin-vue-admin go-admin 参考文档 gin-vue-admin server ","permalink":"https://eveneko.com/posts/go-tutorial/","summary":"Go 模块 web 开发框架: gin orm 库: gorm 日志: logrus, zap Redis 客户端: go-redis Session 管理: go-session Go 设计模式: go-patterns Gin 官方文档: Gin 学习文章参考 Golang-100-Days Go语言高级编程 Go语言圣经 Go Modules 入门 跟煎鱼学Go golangbot Go 开发者成长路线图 参考项目 gin-vue-admin go-admin 参考文档 gin-vue-admin server","title":"Go 学习路线"},{"content":"Docker Install 1 sudo apt install docker.io Docker 配置镜像加速器 针对 Docker 客户端版本大于 1.10.0 的用户，可以通过修改daemon配置文件 /etc/docker/daemon.json 来使用加速器\n1 2 3 4 5 6 7 8 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://4pvkfoz4.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker Docker 参数详解 docker image 查看本机镜像\ndocker search 搜索镜像\ndocker pull 拉取镜像\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] 执行镜像\n-d, --detach=false， 指定容器运行于前台还是后台，默认为false\n-i, --interactive=false， 打开STDIN，用于控制台交互\n-t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false\n-u, --user=\u0026quot;\u0026quot;， 指定容器的用户\n-a, --attach=[]， 登录容器（必须是以docker run -d启动的容器）\n-c, --cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用\n-e, --env=[]， 指定环境变量，容器中可以使用该环境变量\n-m, --memory=\u0026quot;\u0026quot;， 指定容器的内存上限\n-P, --publish-all=false， 指定容器暴露的端口\n-p, --publish=[]， 指定容器暴露的端口\n-h, --hostname=\u0026quot;\u0026quot;， 指定容器的主机名\n-v, --volume=[]， 给容器挂载存储卷，挂载到容器的某个目录\n--volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录\n--cap-add=[]， 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities\n--cap-drop=[]， 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities\n--cidfile=\u0026quot;\u0026quot;， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法\n--cpuset=\u0026quot;\u0026quot;， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU\n--device=[]， 添加主机设备给容器，相当于设备直通\n--dns=[]， 指定容器的dns服务器\n--dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件\n--entrypoint=\u0026quot;\u0026quot;， 覆盖image的入口点\n--env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量\n--expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口\n--link=[]， 指定容器间的关联，使用其他容器的IP、env等信息\n--lxc-conf=[]， 指定容器的配置文件，只有在指定\u0026ndash;exec-driver=lxc时使用\n--name=\u0026quot;\u0026quot;， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字\n--net=\u0026quot;bridge\u0026quot;， 容器网络设置:\nbridge 使用docker daemon指定的网桥\nhost //容器使用主机的网络\ncontainer:NAME_or_ID \u0026gt;//使用其他容器的网路，共享IP和PORT等网络资源\nnone 容器使用自己的网络（类似\u0026ndash;net=bridge），但是不进行配置\n--privileged=false， 指定容器是否为特权容器，特权容器拥有所有的capabilities\n--restart=\u0026quot;no\u0026quot;， 指定容器停止后的重启策略:\nno：容器退出时不重启\non-failure：容器故障退出（返回值非零）时重启\nalways：容器退出时总是重启\n--rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)\n--sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理\ndocker exec 执行容器\ndocker start [CONTAINER_ID/CONTAINER_NAME] 打开容器\ndocker stop [CONTAINER_ID/CONTAINER_NAME] 关闭容器\ndocker rm [CONTAINER_ID/CONTAINER_NAME] 删除容器\ndocker export [CONTAINER_ID/CONTAINER_NAME] \u0026gt; [CONTAIN_SNIPASTE_NAME] 导出容器\ndocker ps -a 查看容器列表\ndocker cp [宿主绝对路径] [CONTAINER_ID/CONTAINER_NAME]:[容器路径] 主机拷贝到容器\ndocker cp [CONTAINER_ID/CONTAINER_NAME]:[容器路径] [宿主绝对路径] 容器拷贝到主机\n","permalink":"https://eveneko.com/posts/docker-tutorial/","summary":"Docker Install 1 sudo apt install docker.io Docker 配置镜像加速器 针对 Docker 客户端版本大于 1.10.0 的用户，可以通过修改daemon配置文件 /etc/docker/daemon.json 来使用加速器 1 2 3 4 5 6 7 8 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://4pvkfoz4.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker Docker 参数详解 docker image 查看本机镜像 docker search 搜索镜像 docker pull 拉取镜像 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 执行镜像 -d, --detach=false， 指定容器运行于前","title":"Docker 使用入门"}]