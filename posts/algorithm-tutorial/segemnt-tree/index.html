<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>线段树(Segment Tree)入门 | Neko Nest</title>
<meta name=keywords content="Algorithm,Segment Tree"><meta name=description content="例题 已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 k 求出某区间每一个数的和。 引入 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。 线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 条件 线段树维护的信息可以认为"><meta name=author content="Eveneko"><link rel=canonical href=https://eveneko.com/posts/algorithm-tutorial/segemnt-tree/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://eveneko.com/images/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://eveneko.com/images/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://eveneko.com/images/logo.svg><link rel=apple-touch-icon href=https://eveneko.com/images/logo.svg><link rel=mask-icon href=https://eveneko.com/images/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="线段树(Segment Tree)入门"><meta property="og:description" content="例题 已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 k 求出某区间每一个数的和。 引入 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。 线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 条件 线段树维护的信息可以认为"><meta property="og:type" content="article"><meta property="og:url" content="https://eveneko.com/posts/algorithm-tutorial/segemnt-tree/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-02T12:40:37+08:00"><meta property="article:modified_time" content="2022-11-02T12:40:37+08:00"><meta property="og:site_name" content="Neko Nest"><meta name=twitter:card content="summary"><meta name=twitter:title content="线段树(Segment Tree)入门"><meta name=twitter:description content="例题 已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 k 求出某区间每一个数的和。 引入 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。 线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 条件 线段树维护的信息可以认为"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://eveneko.com/posts/"},{"@type":"ListItem","position":3,"name":"Algorithm","item":"https://eveneko.com/posts/algorithm-tutorial/"},{"@type":"ListItem","position":4,"name":"线段树(Segment Tree)入门","item":"https://eveneko.com/posts/algorithm-tutorial/segemnt-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"线段树(Segment Tree)入门","name":"线段树(Segment Tree)入门","description":"例题 已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 k 求出某区间每一个数的和。 引入 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。 线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 条件 线段树维护的信息可以认为","keywords":["Algorithm","Segment Tree"],"articleBody":"例题 已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 k 求出某区间每一个数的和。\n引入 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。\n线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。\n条件 线段树维护的信息可以认为是满足（幺）半群的性质\n封闭性 $\\forall x \\in S$, $\\forall y \\in S$ 有 $\\forall x \\circ y \\in S$ 结合律 $\\forall x,y,z \\in S$ 有 $(x \\circ y) \\circ z = x \\circ (y \\circ z)$ 存在幺元 $\\exist e \\in S$ 满足 $\\forall x \\in S$ 有 $e \\circ x = x$，$e$为左幺元；$x \\circ e = x$，$e$为右幺元； 线段树的基本结构与建树 过程 线段树将每个长度不为1的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。\n有个大小为5的数组 $a={10,11,12,13,14}$，要将其转化为线段树，有以下做法：设线段树的根节点编号为1，用数组 $d$ 来保存我们的线段树，$d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。\n图中每个节点中用红色字体标明的区间，表示该节点管辖的 $a$ 数组上的位置区间。如 $d_1$ 所管辖的区间就是 $[1,5] (a_1,a_2,…,a_5)$，即$d_1$所保存的值是$a_1+a_2+…+a_5$， $d_1=60$表示的是$a_1+a_2+…+a_5=60$。\n通过观察不难发现，$d_i$的左儿子节点是$d_2i$，$d_i$的右儿子节点是$d_2i+1$。如果$d_i$表示的是区间$[s,t]$（即$a_s+a_{s+1}+…+a_t$）的话，那么$d_i$的左儿子节点表示的是区间$[s,\\frac{s+t}{2}]$，$d_i$的右儿子节点表示的是区间$[\\frac{s+t}{2}+1,t]$。\n在实现时，我们考虑递归建树。设当前的根节点为 $p$，如果根节点管辖的区间长度已经是 1，则可以直接根据 $a$ 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 void build(int s, int t, int p) { // 对 [s,t] 区间建立线段树,当前根的编号为 p if (s == t) { d[p] = a[s]; return; } int m = s + ((t - s) \u003e\u003e 1); // 移位运算符的优先级小于加减法，所以加上括号 // 如果写成 (s + t) \u003e\u003e 1 可能会超出 int 范围 build(s, m, p * 2), build(m + 1, t, p * 2 + 1); // 递归对左右区间建树 d[p] = d[p * 2] + d[(p * 2) + 1]; } 空间 关于线段树的空间：如果采用堆式存储（ $2p$ 是 $p$ 的左儿子，$2p+1$ 是 $p$ 的右儿子），若有 $n$ 个叶子结点，则 $d$ 数组的范围最大为 $2^{[logn]+1}$。\n分析：容易知道线段树的深度是 $[logn]$ 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^[logn]$ 个，又由于其为一棵完全二叉树，则其总节点个数 $2^{[logn]+1}-1$。当然如果你懒得计算的话可以直接把数组长度设为 4n，因为 $\\frac{2^{[logn]+1}-1}{n}$的最大值在$n=2^x+1$时取到，此时节点数为 $2^{[logn]+1}-1=2^{x+2}-1=4n-5$。\n线段树的区间查询 过程 区间查询，比如求区间 $[l.r]$ 的总和（即 $a_l+a_{l+1}+…+a_r$）、求区间最大值/最小值等操作。\n仍然以最开始的图为例，如果要查询区间 $[1,5]$ 的和，那直接获取 $d_1$ 的值（60）即可。\n如果要查询的区间为 $[3,5]$，此时就不能直接获取区间的值，但是 $[3,5]$ 可以拆成 $[3,3]$ 和 $[4,5]$，可以通过合并这两个区间的答案来求得这个区间的答案。\n一般地，如果要查询的区间是 $[l,r]$，则可以将其拆成最多为 $O(logn)$ 个 极大 的区间，合并这些区间即可求出 $[l,r]$ 的答案。\n实现 1 2 3 4 5 6 7 8 9 10 11 int getsum(int l, int r, int s, int t, int p) { // [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号 if (l \u003c= s \u0026\u0026 t \u003c= r) return d[p]; // 当前区间为询问区间的子集时直接返回当前区间的和 int m = s + ((t - s) \u003e\u003e 1), sum = 0; if (l \u003c= m) sum += getsum(l, r, s, m, p * 2); // 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子 if (r \u003e m) sum += getsum(l, r, m + 1, t, p * 2 + 1); // 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子 return sum; } 线段树的区间修改与懒惰标记 过程 如果要求修改区间 $[l,r]$，把所有包含在区间 $[l,r]$ 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 「lazy标记」 的东西。\nlazy标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。\n仍然以最开始的图为例，我们将执行若干次给区间内的数加上一个值的操作。我们现在给每个节点增加一个 $t_i$，表示该节点带的标记值。\n现在我们准备给 $[3,5]$ 上的每个数都加上 $5$。根据前面区间查询的经验，我们很快找到了两个极大区间 $[3,3]$ 和 $[4,5]$（分别对应线段树上的 $3$ 号点和 $5$ 号点）。\n我们直接在这两个节点上进行修改，并给它们打上标记：\n我们发现，$3$ 号节点的信息虽然被修改了（因为该区间管辖两个数，所以 $d_3$ 加上的数是 $5*2=10$），但它的两个子节点却还没更新，仍然保留着修改之前的信息。不过不用担心，虽然修改目前还没进行，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。\n接下来我们查询一下 $[4,4]$ 区间上各数字的和。\n我们通过递归找到 $[4,5]] 区间，发现该区间并非我们的目标区间，且该区间上还存在标记。这时候就到标记下放的时间了。我们将该区间的两个子区间的信息更新，并清除该区间上的标记。\n现在 $6$、$7$ 两个节点的值变成了最新的值，查询的结果也是准确的。\n实现 区间修改（加值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void update(int l, int r, int c, int s, int t, int p) { // [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p // 为当前节点的编号 if (l \u003c= s \u0026\u0026 t \u003c= r) { d[p] += (t - s + 1) * c, b[p] += c; return; } // 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改 int m = s + ((t - s) \u003e\u003e 1); if (b[p] \u0026\u0026 s != t) { // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值 d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m); b[p * 2] += b[p], b[p * 2 + 1] += b[p]; // 将标记下传给子节点 b[p] = 0; // 清空当前节点的标记 } if (l \u003c= m) update(l, r, c, s, m, p * 2); if (r \u003e m) update(l, r, c, m + 1, t, p * 2 + 1); d[p] = d[p * 2] + d[p * 2 + 1]; } 区间查询（求和）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int getsum(int l, int r, int s, int t, int p) { // [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号 if (l \u003c= s \u0026\u0026 t \u003c= r) return d[p]; // 当前区间为询问区间的子集时直接返回当前区间的和 int m = s + ((t - s) \u003e\u003e 1); if (b[p]) { // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值 d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m); b[p * 2] += b[p], b[p * 2 + 1] += b[p]; // 将标记下传给子节点 b[p] = 0; // 清空当前节点的标记 } int sum = 0; if (l \u003c= m) sum = getsum(l, r, s, m, p * 2); if (r \u003e m) sum += getsum(l, r, m + 1, t, p * 2 + 1); return sum; } 动态开点线段树 前面讲到堆式储存的情况下，需要给线段树开 $4n$ 大小的数组。为了节省空间，我们可以不一次性建好树，而是在最初只建立一个根结点代表整个区间。当我们需要访问某个子区间时，才建立代表这个区间的子结点。这样我们不再使用 $2p$ 和 $2p+1$ 代表 $p$ 结点的儿子，而是用 $ls$ 和 $rs$ 记录儿子的编号。总之，动态开点线段树的核心思想就是：结点只有在有需要的时候才被创建。\n单次操作的时间复杂度是不变的，为 $O(logn)$。由于每次操作都有可能创建并访问全新的一系列结点，因此 m 次单点操作后结点的数量规模是 $O(mlogn)$。最多也只需要 $2n-1$ 个结点，没有浪费。\n实现 单点修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // root 表示整棵线段树的根结点；cnt 表示当前结点个数 int n, cnt, root; int sum[n * 2], ls[n * 2], rs[n * 2]; // 用法：update(root, 1, n, x, f); 其中 x 为待修改节点的编号 void update(int\u0026 p, int s, int t, int x, int f) { // 引用传参 if (!p) p = ++cnt; // 当结点为空时，创建一个新的结点 if (s == t) { sum[p] += f; return; } int m = s + ((t - s) \u003e\u003e 1); if (x \u003c= m) update(ls[p], s, m, x, f); else update(rs[p], m + 1, t, x, f); sum[p] = sum[ls[p]] + sum[rs[p]]; // pushup } 区间询问\n1 2 3 4 5 6 7 8 9 // 用法：query(root, 1, n, l, r); int query(int p, int s, int t, int l, int r) { if (!p) return 0; // 如果结点为空，返回 0 if (s \u003e= l \u0026\u0026 t \u003c= r) return sum[p]; int m = s + ((t - s) \u003e\u003e 1), ans = 0; if (l \u003c= m) ans += query(ls[p], s, m, l, r); if (r \u003e m) ans += query(rs[p], m + 1, t, l, r); return ans; } 区间修改也是一样的，不过下放标记时要注意如果缺少孩子，就直接创建一个新的孩子。或者使用标记永久化技巧。\n优化 在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。 标记永久化技巧 如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。 进阶 - 猫树 众所周知线段树可以支持高速查询某一段区间的信息和，比如区间最大子段和，区间和，区间矩阵的连乘积等等。\n但是有一个问题在于普通线段树的区间询问在某些毒瘤的眼里可能还是有些慢了。\n简单来说就是线段树建树的时候需要做 $O(n)$ 次合并操作，而每一次区间询问需要做 $O(logn)$ 次合并操作，询问区间和这种东西的时候还可以忍受，但是当我们需要询问区间线性基这种合并复杂度高达 $O(log^2\\omega)$ 的信息的话，此时就算是做 O(logn) 次合并有些时候在时间上也是不可接受的。\n线性基是一个数的集合，并且每个序列都拥有至少一个线性基，取线性基中若干个数异或起来可以得到原序列中的任何一个数。\n而所谓“猫树”就是一种不支持修改，仅仅支持快速区间询问的一种静态线段树。 构造一棵这样的静态线段树需要 $O(nlogn)$ 次合并操作，但是此时的查询复杂度被加速至 $O(1)$ 次合并操作。\n在处理线性基这样特殊的信息的时候甚至可以将复杂度降至 $O(nlog^2\\omega)$。\n原理 在查询 $[l,r]$ 这段区间的信息和的时候，将线段树树上代表 $[l,l]$ 的节点和代表 $[r,r]$ 这段区间的节点在线段树上的 LCA 求出来，设这个节点 $p$ 代表的区间为 $[L,R]$，我们会发现一些非常有趣的性质：\n$[L,R]$这个区间一定包含 $[l,r]$。显然，因为它既是 $l$ 的祖先又是 $$ 的祖先。 $[l,r]$这个区间一定跨越 $[L,R]$ 的中点。由于 $p$ 是 $l$ 和 $r$ 的 LCA，这意味着 $p$ 的左儿子是 $l$ 的祖先而不是 $r$ 的祖先，$p$ 的右儿子是 $r$ 的祖先而不是 $l$ 的祖先。因此，$l$ 一定在 $[L,mid]$ 这个区间内，$r$ 一定在 $[mid,R]$ 这个区间内。 有了这两个性质，我们就可以将询问的复杂度降至 $O(1)$ 了。 实现 具体来讲我们建树的时候对于线段树树上的一个节点，设它代表的区间为 $(l,r]$。\n不同于传统线段树在这个节点里只保留 $[l,r]$ 的和，我们在这个节点里面额外保存 $(l,mid]$ 的后缀和数组和 $(mid,r]$ 的前缀和数组。\n这样的话建树的复杂度为 $T(n)=2T(n/2)+O(n)=O(nlogn)$ 同理空间复杂度也从原来的 $O(n)$ 变成了 $O(nlogn)$。\n下面是最关键的询问了。\n如果我们询问的区间是 $[l,r]$ 那么我们把代表 $[l,l]$ 的节点和代表 $[r,r]$ 的节点的 LCA 求出来，记为 $p$。\n根据刚才的两个性质，$l,r$ 在 $p$ 所包含的区间之内并且一定跨越了 $p$ 的中点。\n这意味这一个非常关键的事实是我们可以使用 $p$ 里面的前缀和数组和后缀和数组，将 $[l,r]$ 拆成 $[l,mid]+(mid,r]$ 从而拼出来 $[l,r]$ 这个区间。\n而这个过程仅仅需要 $O(1)$ 次合并操作！\n当然如何求LCA，已经在这上面的优化，这次就不说。\n","wordCount":"4655","inLanguage":"zh","datePublished":"2022-11-02T12:40:37+08:00","dateModified":"2022-11-02T12:40:37+08:00","author":{"@type":"Person","name":"Eveneko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://eveneko.com/posts/algorithm-tutorial/segemnt-tree/"},"publisher":{"@type":"Organization","name":"Neko Nest","logo":{"@type":"ImageObject","url":"https://eveneko.com/images/logo.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://eveneko.com accesskey=h title="Neko Nest (Alt + H)"><img src=https://eveneko.com/images/logo.svg alt aria-label=logo height=35>Neko Nest</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://eveneko.com/search/ title="🔍 搜索"><span>🔍 搜索</span></a></li><li><a href=https://eveneko.com/archives/ title="🕙 时间轴"><span>🕙 时间轴</span></a></li><li><a href=https://eveneko.com/categories/ title="🧩 分类"><span>🧩 分类</span></a></li><li><a href=https://eveneko.com/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://eveneko.com/about/ title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://eveneko.com>主页</a>&nbsp;»&nbsp;<a href=https://eveneko.com/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://eveneko.com/posts/algorithm-tutorial/>Algorithm</a></div><h1 class=post-title>线段树(Segment Tree)入门</h1><div class=post-meta>&lt;span title='2022-11-02 12:40:37 +0800 +0800'>2022-11-02&lt;/span>&amp;nbsp;·&amp;nbsp;10 分钟&amp;nbsp;·&amp;nbsp;4655 字&amp;nbsp;·&amp;nbsp;Eveneko&nbsp;|&nbsp;<a href=https://github.com/Eveneko/Blob-Source/edit/master/content/posts/algorithm-tutorial/segemnt-tree.md rel="noopener noreferrer" target=_blank>Edit on GitHub</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#例题>例题</a></li><li><a href=#引入>引入</a></li><li><a href=#条件>条件</a></li><li><a href=#线段树的基本结构与建树>线段树的基本结构与建树</a><ul><li><a href=#过程>过程</a></li><li><a href=#实现>实现</a></li><li><a href=#空间>空间</a></li></ul></li><li><a href=#线段树的区间查询>线段树的区间查询</a><ul><li><a href=#过程-1>过程</a></li><li><a href=#实现-1>实现</a></li></ul></li><li><a href=#线段树的区间修改与懒惰标记>线段树的区间修改与懒惰标记</a><ul><li><a href=#过程-2>过程</a></li><li><a href=#实现-2>实现</a></li></ul></li><li><a href=#动态开点线段树>动态开点线段树</a><ul><li><a href=#实现-3>实现</a></li></ul></li><li><a href=#优化>优化</a></li><li><a href=#进阶---猫树>进阶 - 猫树</a><ul><li><a href=#原理>原理</a></li><li><a href=#实现-4>实现</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=例题>例题<a hidden class=anchor aria-hidden=true href=#例题>#</a></h2><blockquote><p>已知一个数列，你需要进行下面两种操作：
将某区间每一个数加上 k
求出某区间每一个数的和。</p></blockquote><h2 id=引入>引入<a hidden class=anchor aria-hidden=true href=#引入>#</a></h2><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><h2 id=条件>条件<a hidden class=anchor aria-hidden=true href=#条件>#</a></h2><p>线段树维护的信息可以认为是满足（幺）半群的性质</p><ul><li>封闭性<ul><li>$\forall x \in S$, $\forall y \in S$ 有 $\forall x \circ y \in S$</li></ul></li><li>结合律<ul><li>$\forall x,y,z \in S$ 有 $(x \circ y) \circ z = x \circ (y \circ z)$</li></ul></li><li>存在幺元<ul><li>$\exist e \in S$ 满足 $\forall x \in S$ 有 $e \circ x = x$，$e$为左幺元；$x \circ e = x$，$e$为右幺元；</li></ul></li></ul><h2 id=线段树的基本结构与建树>线段树的基本结构与建树<a hidden class=anchor aria-hidden=true href=#线段树的基本结构与建树>#</a></h2><h3 id=过程>过程<a hidden class=anchor aria-hidden=true href=#过程>#</a></h3><p>线段树将每个长度不为1的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p><p>有个大小为5的数组 $a={10,11,12,13,14}$，要将其转化为线段树，有以下做法：设线段树的根节点编号为1，用数组 $d$ 来保存我们的线段树，$d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。</p><p><img loading=lazy src=https://cdn.staticaly.com/gh/Eveneko/Source-Hosting@master/PicX/image.1imqif840szk.webp alt=image></p><p>图中每个节点中用红色字体标明的区间，表示该节点管辖的 $a$ 数组上的位置区间。如 $d_1$ 所管辖的区间就是 $[1,5] (a_1,a_2,&mldr;,a_5)$，即$d_1$所保存的值是$a_1+a_2+&mldr;+a_5$， $d_1=60$表示的是$a_1+a_2+&mldr;+a_5=60$。</p><p>通过观察不难发现，$d_i$的左儿子节点是$d_2<em>i$，$d_i$的右儿子节点是$d_2</em>i+1$。如果$d_i$表示的是区间$[s,t]$（即$a_s+a_{s+1}+&mldr;+a_t$）的话，那么$d_i$的左儿子节点表示的是区间$[s,\frac{s+t}{2}]$，$d_i$的右儿子节点表示的是区间$[\frac{s+t}{2}+1,t]$。</p><p>在实现时，我们考虑递归建树。设当前的根节点为 $p$，如果根节点管辖的区间长度已经是 1，则可以直接根据 $a$ 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。</p><h3 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>build</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 对 [s,t] 区间建立线段树,当前根的编号为 p
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>==</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>s</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=p>((</span><span class=n>t</span> <span class=o>-</span> <span class=n>s</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 移位运算符的优先级小于加减法，所以加上括号
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>build</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>),</span> <span class=n>build</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 递归对左右区间建树
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>d</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>=</span> <span class=n>d</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>d</span><span class=p>[(</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=空间>空间<a hidden class=anchor aria-hidden=true href=#空间>#</a></h3><p>关于线段树的空间：如果采用堆式存储（ $2p$ 是 $p$ 的左儿子，$2p+1$ 是 $p$ 的右儿子），若有 $n$ 个叶子结点，则 $d$ 数组的范围最大为 $2^{[logn]+1}$。</p><p>分析：容易知道线段树的深度是 $[logn]$ 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^[logn]$ 个，又由于其为一棵完全二叉树，则其总节点个数 $2^{[logn]+1}-1$。当然如果你懒得计算的话可以直接把数组长度设为 4n，因为 $\frac{2^{[logn]+1}-1}{n}$的最大值在$n=2^x+1$时取到，此时节点数为 $2^{[logn]+1}-1=2^{x+2}-1=4n-5$。</p><h2 id=线段树的区间查询>线段树的区间查询<a hidden class=anchor aria-hidden=true href=#线段树的区间查询>#</a></h2><h3 id=过程-1>过程<a hidden class=anchor aria-hidden=true href=#过程-1>#</a></h3><p>区间查询，比如求区间 $[l.r]$ 的总和（即 $a_l+a_{l+1}+&mldr;+a_r$）、求区间最大值/最小值等操作。</p><p>仍然以最开始的图为例，如果要查询区间 $[1,5]$ 的和，那直接获取 $d_1$ 的值（60）即可。</p><p>如果要查询的区间为 $[3,5]$，此时就不能直接获取区间的值，但是 $[3,5]$ 可以拆成 $[3,3]$ 和 $[4,5]$，可以通过合并这两个区间的答案来求得这个区间的答案。</p><p>一般地，如果要查询的区间是 $[l,r]$，则可以将其拆成最多为 $O(logn)$ 个 <strong>极大</strong> 的区间，合并这些区间即可求出 $[l,r]$ 的答案。</p><h3 id=实现-1>实现<a hidden class=anchor aria-hidden=true href=#实现-1>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getsum</span><span class=p>(</span><span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>s</span> <span class=o>&amp;&amp;</span> <span class=n>t</span> <span class=o>&lt;=</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>d</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>  <span class=c1>// 当前区间为询问区间的子集时直接返回当前区间的和
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=p>((</span><span class=n>t</span> <span class=o>-</span> <span class=n>s</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>),</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>)</span> <span class=n>sum</span> <span class=o>+=</span> <span class=n>getsum</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=n>sum</span> <span class=o>+=</span> <span class=n>getsum</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=线段树的区间修改与懒惰标记>线段树的区间修改与懒惰标记<a hidden class=anchor aria-hidden=true href=#线段树的区间修改与懒惰标记>#</a></h2><h3 id=过程-2>过程<a hidden class=anchor aria-hidden=true href=#过程-2>#</a></h3><p>如果要求修改区间 $[l,r]$，把所有包含在区间 $[l,r]$ 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 「lazy标记」 的东西。</p><p>lazy标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><p>仍然以最开始的图为例，我们将执行若干次给区间内的数加上一个值的操作。我们现在给每个节点增加一个 $t_i$，表示该节点带的标记值。</p><p><img loading=lazy src=https://cdn.staticaly.com/gh/Eveneko/Source-Hosting@master/PicX/image.5b1fjia2t8jk.webp alt=image></p><p>现在我们准备给 $[3,5]$ 上的每个数都加上 $5$。根据前面区间查询的经验，我们很快找到了两个极大区间 $[3,3]$ 和 $[4,5]$（分别对应线段树上的 $3$ 号点和 $5$ 号点）。</p><p>我们直接在这两个节点上进行修改，并给它们打上标记：</p><p><img loading=lazy src=https://cdn.staticaly.com/gh/Eveneko/Source-Hosting@master/PicX/image.kw6l3igt6yo.webp alt=image></p><p>我们发现，$3$ 号节点的信息虽然被修改了（因为该区间管辖两个数，所以 $d_3$ 加上的数是 $5*2=10$），但它的两个子节点却还没更新，仍然保留着修改之前的信息。不过不用担心，虽然修改目前还没进行，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。</p><p>接下来我们查询一下 $[4,4]$ 区间上各数字的和。</p><p>我们通过递归找到 $[4,5]] 区间，发现该区间并非我们的目标区间，且该区间上还存在标记。这时候就到标记下放的时间了。我们将该区间的两个子区间的信息更新，并清除该区间上的标记。</p><p><img loading=lazy src=https://cdn.staticaly.com/gh/Eveneko/Source-Hosting@master/PicX/image.2j29yyh05l4w.webp alt=image></p><p>现在 $6$、$7$ 两个节点的值变成了最新的值，查询的结果也是准确的。</p><h3 id=实现-2>实现<a hidden class=anchor aria-hidden=true href=#实现-2>#</a></h3><p>区间修改（加值）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// 为当前节点的编号
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>s</span> <span class=o>&amp;&amp;</span> <span class=n>t</span> <span class=o>&lt;=</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>+=</span> <span class=p>(</span><span class=n>t</span> <span class=o>-</span> <span class=n>s</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>c</span><span class=p>,</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>+=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>  <span class=c1>// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=p>((</span><span class=n>t</span> <span class=o>-</span> <span class=n>s</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>s</span> <span class=o>!=</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>m</span> <span class=o>-</span> <span class=n>s</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>d</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>t</span> <span class=o>-</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>  <span class=c1>// 将标记下传给子节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>                                <span class=c1>// 清空当前节点的标记
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>)</span> <span class=n>update</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=n>update</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>d</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>=</span> <span class=n>d</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>d</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>区间查询（求和）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>getsum</span><span class=p>(</span><span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>s</span> <span class=o>&amp;&amp;</span> <span class=n>t</span> <span class=o>&lt;=</span> <span class=n>r</span><span class=p>)</span> <span class=k>return</span> <span class=n>d</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 当前区间为询问区间的子集时直接返回当前区间的和
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=p>((</span><span class=n>t</span> <span class=o>-</span> <span class=n>s</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>d</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>m</span> <span class=o>-</span> <span class=n>s</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>d</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>t</span> <span class=o>-</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+=</span> <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>  <span class=c1>// 将标记下传给子节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>b</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>                                <span class=c1>// 清空当前节点的标记
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>)</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>getsum</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=n>sum</span> <span class=o>+=</span> <span class=n>getsum</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=动态开点线段树>动态开点线段树<a hidden class=anchor aria-hidden=true href=#动态开点线段树>#</a></h2><p>前面讲到堆式储存的情况下，需要给线段树开 $4n$ 大小的数组。为了节省空间，我们可以不一次性建好树，而是在最初只建立一个根结点代表整个区间。当我们需要访问某个子区间时，才建立代表这个区间的子结点。这样我们不再使用 $2p$ 和 $2p+1$ 代表 $p$ 结点的儿子，而是用 $ls$ 和 $rs$ 记录儿子的编号。总之，动态开点线段树的核心思想就是：<strong>结点只有在有需要的时候才被创建</strong>。</p><p>单次操作的时间复杂度是不变的，为 $O(logn)$。由于每次操作都有可能创建并访问全新的一系列结点，因此 m 次单点操作后结点的数量规模是 $O(mlogn)$。最多也只需要 $2n-1$ 个结点，没有浪费。</p><h3 id=实现-3>实现<a hidden class=anchor aria-hidden=true href=#实现-3>#</a></h3><p>单点修改</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// root 表示整棵线段树的根结点；cnt 表示当前结点个数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>cnt</span><span class=p>,</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span><span class=p>[</span><span class=n>n</span> <span class=o>*</span> <span class=mi>2</span><span class=p>],</span> <span class=n>ls</span><span class=p>[</span><span class=n>n</span> <span class=o>*</span> <span class=mi>2</span><span class=p>],</span> <span class=n>rs</span><span class=p>[</span><span class=n>n</span> <span class=o>*</span> <span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 用法：update(root, 1, n, x, f); 其中 x 为待修改节点的编号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>update</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>f</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 引用传参
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p</span><span class=p>)</span> <span class=n>p</span> <span class=o>=</span> <span class=o>++</span><span class=n>cnt</span><span class=p>;</span>  <span class=c1>// 当结点为空时，创建一个新的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>==</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sum</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>+=</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=p>((</span><span class=n>t</span> <span class=o>-</span> <span class=n>s</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=p>(</span><span class=n>ls</span><span class=p>[</span><span class=n>p</span><span class=p>],</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>update</span><span class=p>(</span><span class=n>rs</span><span class=p>[</span><span class=n>p</span><span class=p>],</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>sum</span><span class=p>[</span><span class=n>p</span><span class=p>]</span> <span class=o>=</span> <span class=n>sum</span><span class=p>[</span><span class=n>ls</span><span class=p>[</span><span class=n>p</span><span class=p>]]</span> <span class=o>+</span> <span class=n>sum</span><span class=p>[</span><span class=n>rs</span><span class=p>[</span><span class=n>p</span><span class=p>]];</span>  <span class=c1>// pushup
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>区间询问</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 用法：query(root, 1, n, l, r);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>query</span><span class=p>(</span><span class=kt>int</span> <span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>t</span><span class=p>,</span> <span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>  <span class=c1>// 如果结点为空，返回 0
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>s</span> <span class=o>&gt;=</span> <span class=n>l</span> <span class=o>&amp;&amp;</span> <span class=n>t</span> <span class=o>&lt;=</span> <span class=n>r</span><span class=p>)</span> <span class=k>return</span> <span class=n>sum</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=p>((</span><span class=n>t</span> <span class=o>-</span> <span class=n>s</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>),</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>)</span> <span class=n>ans</span> <span class=o>+=</span> <span class=n>query</span><span class=p>(</span><span class=n>ls</span><span class=p>[</span><span class=n>p</span><span class=p>],</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>&gt;</span> <span class=n>m</span><span class=p>)</span> <span class=n>ans</span> <span class=o>+=</span> <span class=n>query</span><span class=p>(</span><span class=n>rs</span><span class=p>[</span><span class=n>p</span><span class=p>],</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ans</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>区间修改也是一样的，不过下放标记时要注意如果缺少孩子，就直接创建一个新的孩子。或者使用标记永久化技巧。</p><h2 id=优化>优化<a hidden class=anchor aria-hidden=true href=#优化>#</a></h2><ul><li>在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。</li><li>标记永久化技巧<ul><li>如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。</li></ul></li></ul><h2 id=进阶---猫树>进阶 - 猫树<a hidden class=anchor aria-hidden=true href=#进阶---猫树>#</a></h2><p>众所周知线段树可以支持高速查询某一段区间的信息和，比如区间最大子段和，区间和，区间矩阵的连乘积等等。</p><p>但是有一个问题在于普通线段树的区间询问在某些毒瘤的眼里可能还是有些慢了。</p><p>简单来说就是线段树建树的时候需要做 $O(n)$ 次合并操作，而每一次区间询问需要做 $O(logn)$ 次合并操作，询问区间和这种东西的时候还可以忍受，但是当我们需要询问区间线性基这种合并复杂度高达 $O(log^2\omega)$ 的信息的话，此时就算是做 O(logn) 次合并有些时候在时间上也是不可接受的。</p><blockquote><p>线性基是一个数的集合，并且每个序列都拥有至少一个线性基，取线性基中若干个数异或起来可以得到原序列中的任何一个数。</p></blockquote><p>而所谓“猫树”就是一种不支持修改，仅仅支持快速区间询问的一种静态线段树。
构造一棵这样的静态线段树需要 $O(nlogn)$ 次合并操作，但是此时的查询复杂度被加速至 $O(1)$ 次合并操作。</p><p>在处理线性基这样特殊的信息的时候甚至可以将复杂度降至 $O(nlog^2\omega)$。</p><h3 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h3><p>在查询 $[l,r]$ 这段区间的信息和的时候，将线段树树上代表 $[l,l]$ 的节点和代表 $[r,r]$ 这段区间的节点在线段树上的 LCA 求出来，设这个节点 $p$ 代表的区间为 $[L,R]$，我们会发现一些非常有趣的性质：</p><ol><li>$[L,R]$这个区间一定包含 $[l,r]$。显然，因为它既是 $l$ 的祖先又是 $$ 的祖先。</li><li>$[l,r]$这个区间一定跨越 $[L,R]$ 的中点。由于 $p$ 是 $l$ 和 $r$ 的 LCA，这意味着 $p$ 的左儿子是 $l$ 的祖先而不是 $r$ 的祖先，$p$ 的右儿子是 $r$ 的祖先而不是 $l$ 的祖先。因此，$l$ 一定在 $[L,mid]$ 这个区间内，$r$ 一定在 $[mid,R]$ 这个区间内。
有了这两个性质，我们就可以将询问的复杂度降至 $O(1)$ 了。</li></ol><h3 id=实现-4>实现<a hidden class=anchor aria-hidden=true href=#实现-4>#</a></h3><p>具体来讲我们建树的时候对于线段树树上的一个节点，设它代表的区间为 $(l,r]$。</p><p>不同于传统线段树在这个节点里只保留 $[l,r]$ 的和，我们在这个节点里面额外保存 $(l,mid]$ 的后缀和数组和 $(mid,r]$ 的前缀和数组。</p><p>这样的话建树的复杂度为 $T(n)=2T(n/2)+O(n)=O(nlogn)$ 同理空间复杂度也从原来的 $O(n)$ 变成了 $O(nlogn)$。</p><p>下面是最关键的询问了。</p><p>如果我们询问的区间是 $[l,r]$ 那么我们把代表 $[l,l]$ 的节点和代表 $[r,r]$ 的节点的 LCA 求出来，记为 $p$。</p><p>根据刚才的两个性质，$l,r$ 在 $p$ 所包含的区间之内并且一定跨越了 $p$ 的中点。</p><p>这意味这一个非常关键的事实是我们可以使用 $p$ 里面的前缀和数组和后缀和数组，将 $[l,r]$ 拆成 $[l,mid]+(mid,r]$ 从而拼出来 $[l,r]$ 这个区间。</p><p>而这个过程仅仅需要 $O(1)$ 次合并操作！</p><p>当然如何求LCA，已经在这上面的优化，这次就不说。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://eveneko.com/tags/algorithm/>Algorithm</a></li><li><a href=https://eveneko.com/tags/segment-tree/>Segment Tree</a></li></ul><nav class=paginav><a class=prev href=https://eveneko.com/posts/master-thesis/><span class=title>« 上一页</span><br><span>研究生论文方向: 基于hideen memory mapping的固件仿真及检测框架</span>
</a><a class=next href=https://eveneko.com/posts/firmware-readpaper/><span class=title>下一页 »</span><br><span>Firmware Readpaper</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://eveneko.com>Neko Nest</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>